<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>github_version.env.loadEnvironment API documentation</title>
<meta name="description" content="Loads the environment from images of sheltering data and population density data. Also includes methods for modifying the population density and â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>github_version.env.loadEnvironment</code></h1>
</header>
<section id="section-intro">
<p>Loads the environment from images of sheltering data and population density data. Also includes methods for modifying the population density and scaling the environment.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Loads the environment from images of sheltering data and population density data. Also includes methods for modifying the population density and scaling the environment.
&#39;&#39;&#39;

from PIL import Image
import numpy as np
# import matplotlib.pyplot as plt
# from env.RiskMap2 import shelter_matrix
import math
from skimage.util import view_as_blocks
from scipy import stats
import scipy.ndimage
from warnings import warn

cities = {&#34;Delft&#34;:
                # total population = 67868 people
              {&#34;url_pop&#34;: &#34;env/city_inputs/delft/delftdichtheid2.png&#34;,
               &#34;url_shelter&#34;: &#34;env/city_inputs/delft/delft_v3_edited.png&#34;, # Make sure that the same file is used here as in the __main__!!!!
               &#34;url_modifyPopDens&#34;: &#34;env/city_inputs/delft/modify_pop_dens.png&#34;,
               &#34;width_meters&#34;: 4600,
               &#34;height_meters&#34;: 3800,
               },
          &#34;UniformTown&#34;:
              {&#34;url_pop&#34;: None,
               &#34;url_shelter&#34;: None,
               &#34;url_modifyPopDens&#34;: None,
               &#34;width_meters&#34;: 4600,
               &#34;height_meters&#34;: 3800},
          &#34;NewTown&#34;:
              {&#34;url_pop&#34;: None,
               &#34;url_shelter&#34;: &#34;env/city_inputs/newtown/newtown.png&#34;,
               &#34;url_modifyPopDens&#34;: None,
               &#34;width_meters&#34;: 1000,
               &#34;height_meters&#34;: 1000},
          &#34;NewYork&#34;:
          # total population = 1.26m people
              {&#34;url_pop&#34;: &#34;env/city_inputs/newyork/NY_popdens_v3.png&#34;,
               &#34;url_modifyPopDens&#34;: &#34;env/city_inputs/newyork/office_or_home.png&#34;,
               &#34;url_shelter&#34;: &#34;env/city_inputs/newyork/ny_corrected_map.png&#34;,
                &#34;width_meters&#34;: 9300,
               &#34;height_meters&#34;: 8700
               },
          &#34;Paris&#34;:
          # total popoulation = 3.84m people
              {&#34;url_pop&#34;: &#34;env/city_inputs/paris/paris_dens_map_v3.png&#34;,
               &#34;url_modifyPopDens&#34;: &#34;&#34;,
               &#34;url_shelter&#34;: &#34;env/city_inputs/paris/paris_output_v2.png&#34;,
               &#34;width_meters&#34;: 12000,
               &#34;height_meters&#34;: 10400
               },
          &#34;CityGrid&#34;:
              {&#34;url_pop&#34;: None,
               &#34;url_shelter&#34;: None,
               &#34;url_modifyPopDens&#34;: None,
               &#34;width_meters&#34;: 1000,
               &#34;height_meters&#34;: 1000}
          }

# if __name__ == &#34;__main__&#34;:
    #
    # new_shelter_url = &#34;city_inputs/delft/delft_v3_edited.png&#34;
    # new_popdens_url = &#34;city_inputs/delft/delftdichtheid2.png&#34;
    # new_modifypopdens_url = &#34;city_inputs/delft/modify_pop_dens.png&#34;
    # if (&#34;env/&#34; + new_shelter_url) != cities[&#34;Delft&#34;][&#34;url_shelter&#34;]:
    #     raise Exception(&#34;shelter_matrix urls are not matching&#34;)
    # if (&#34;env/&#34; + new_popdens_url) != cities[&#34;Delft&#34;][&#34;url_pop&#34;]:
    #     raise Exception(&#34;Popdens urls are not matching&#34;)
    # if (&#34;env/&#34; + new_modifypopdens_url) != cities[&#34;Delft&#34;][&#34;url_modifyPopDens&#34;]:
    #     raise Exception(&#34;Modifypopdens urls are not matching&#34;)
    #
    # cities[&#34;Delft&#34;][&#34;url_pop&#34;] = new_popdens_url
    # cities[&#34;Delft&#34;][&#34;url_shelter&#34;] = new_shelter_url
    # cities[&#34;Delft&#34;][&#34;url_modifyPopDens&#34;] = new_modifypopdens_url
    # cities[&#34;NewTown&#34;][&#34;url_shelter&#34;] = &#34;city_inputs/newtown/newtown.png&#34;
    # import matplotlib.pyplot as plt


class loadEnvironment():
    def __init__(self, city=&#34;Delft&#34;, pop_dens_scenario=None, scaling_factor=1, risk_map_resolution=1, water_setting = 0, modify_dens_list = []):
        &#34;&#34;&#34;
        The loadEnvironment class, which loads the cities
        city: Chooses the city to load
        scaling_factor: the factor by which all regular maps are scaled (this is used for path-finding)
        risk_map_resolution: the factor by which all _risk maps are scaled (these are used for risk-computation)
        water_setting: whether or not to remove all pop dens from water (0 = no pop dens on water)
        modify_dens_list: accepts a list which can be used to modify pop density

        &#34;&#34;&#34;
        self.purge_cache = True
        self.waterSetting = water_setting
        self.url_pop = cities[city][&#34;url_pop&#34;]
        self.url_shelter = cities[city][&#34;url_shelter&#34;]
        self.url_modifyPopDens = cities[city][&#34;url_modifyPopDens&#34;]

        self.scaling_factor_normal = scaling_factor
        self.scaling_factor_risk = risk_map_resolution

        self.city = city

        self.width_meters = cities[city][&#34;width_meters&#34;]
        self.height_meters = cities[city][&#34;height_meters&#34;]

        # These two functions load all pop-, and sheltering-data
        self.loadPopulationDensity()
        self.loadShelteringData()
        self.shelter_matrix[self.shelter_matrix == 0] = 0.001


        self.shelter_category_names = np.append(self.shelter_category_names, &#34;hub&#34;)
        self.shelter_category_names = np.append(self.shelter_category_names, &#34;delivery point&#34;)


        # A function which has some statistics on how big the area of each category is.
        self.area_per_shelter_category = np.zeros((len(self.shelter_category_names)))
        for i in range(len(self.area_per_shelter_category)):
            self.area_per_shelter_category[i] = np.count_nonzero(self.shelter_category == i)


        # if pop_dens_scenario == &#34;working_hours&#34;:
        #     if self.city != &#34;Delft&#34;:
        #         raise Exception(&#34;Modifying pop density only supported for delft&#34;)
        #
        #     self.modifyPopulationDensity(target_home=0.0, target_office=(0.0), target_transport=1.0, target_other=0.0)
        #     self.density_matrix = self.densitymatrix_modified.copy()

        if water_setting == 1:
            self.modifyPopDensityWater()
        elif water_setting == 0 :
            self.removePopDensityFromWater() # TODO: This is undone by modifying pop density
        # else:
        #     print(&#34;WARNING: not doing anything with water as city is NY&#34;)


        # Usually: [&#39;Error&#39; &#39;Office&#39; &#39;Water&#39; &#39;Street&#39; &#39;Event Location&#39; &#39;Home Area&#39;, &#39;Small Street&#39; &#39;Meadow&#39;]
        if len(modify_dens_list) &gt; 0:
            self.modifyPopulationDensity(modify_dens_list) # Hub &amp; Deliverypoint are only appended later so therefore this is the correct size of the array.
            self.density_matrix = self.density_matrix_modified.copy()



        # In the following, all maps are scaled. For density-maps, &#34;average&#34; scaling has shown to be optimal,
        # while for sheltering, &#34;mode&#34; has shown to be optimal
        self.density_matrix_scaled = self.scaleMap(self.density_matrix, scaling_factor=self.scaling_factor_normal,
                                                   scaling_method=&#34;average&#34;, file_name=&#34;density_matrix_scaled&#34;)
        self.shelter_map_scaled = self.scaleMap(self.shelter_matrix, scaling_factor=self.scaling_factor_normal,
                                                scaling_method=&#34;mode&#34;, file_name=&#34;shelter_map_scaled&#34;)

        self.density_matrix_scaled_risk = self.scaleMap(self.density_matrix, scaling_factor=self.scaling_factor_risk,
                                                        scaling_method=&#34;average&#34;, file_name=&#34;density_matrix_scaled_risk&#34;)
        self.shelter_map_scaled_risk = self.scaleMap(self.shelter_matrix, scaling_factor=self.scaling_factor_risk,
                                                     scaling_method=&#34;mode&#34;, file_name=&#34;shelter_map_scaled_risk&#34;)

        self.shelter_category = self.shelter_category
        self.shelter_category_scaled = self.scaleMap(self.shelter_category, scaling_factor=self.scaling_factor_normal,
                                                           scaling_method=&#34;mode&#34;, file_name=&#34;shelter_category_scaled&#34;)  # TODO scale this appropriately for both risk and pathfinding

        self.shelter_category_scaled_risk = self.scaleMap(self.shelter_category, scaling_factor=self.scaling_factor_risk,
                                                                scaling_method=&#34;mode&#34;, file_name=&#34;shelter_category_scaled_risk&#34;)




        # Extract the parameters of the maps (sizes etc)
        self.Width = self.shelter_map_scaled.shape[0]
        self.Height = self.shelter_map_scaled.shape[1]
        self.width_risk = self.density_matrix_scaled_risk.shape[0]
        self.height_risk = self.density_matrix_scaled_risk.shape[1]

        self.width_risk_m = self.width_meters / self.width_risk
        self.height_risk_m = self.height_meters / self.height_risk

        self.risk_grid_size_m_x = self.width_meters / self.density_matrix_scaled_risk.shape[0]
        self.risk_grid_size_m_y = self.height_meters / self.density_matrix_scaled_risk.shape[1]

        self.grid_size_m_x = self.width_meters / self.density_matrix_scaled.shape[0]
        self.grid_size_m_y = self.height_meters / self.density_matrix_scaled.shape[1]

        self.area_risk_m = self.width_risk_m * self.height_risk_m

        self.statisticsPopulationDensity(verbose=False)  # This function is required for some other things

        if (self.density_matrix_scaled.shape != self.shelter_map_scaled.shape) or (self.density_matrix.shape != self.shelter_matrix.shape) or (
                self.density_matrix_scaled_risk.shape != self.shelter_map_scaled_risk.shape) or (self.shelter_category_scaled_risk.shape != self.density_matrix_scaled_risk.shape) or (self.shelter_category_scaled.shape != self.shelter_map_scaled.shape):
            raise Exception(&#34;Dimensions of density matrix and sheltering do not match&#34;)



        if self.density_matrix.shape != self.shelter_matrix.shape:
            raise Exception(&#34;Dimensions of Density Matrix and Sheltering Map differ&#34;)

        # elif self.densitymatrix_scaled.shape != self.Shelter_scaled.shape:
        #     print(self.densitymatrix_scaled.shape)
        #     print(self.Shelter_scaled.shape)
        #     # raise Exception(&#34;Dimensions of scaled Density Matrix and Sheltering Map differ&#34;)

    def loadPopulationDensity(self):
        &#39;&#39;&#39;
        Method that is ran whenever the loadEnvironment class is initialized. It loads the population density of the current city.
        &#39;&#39;&#39;
        if self.city == &#34;CityGrid&#34;:
            return
        if self.url_pop == None:
            if self.city == &#34;UniformTown&#34;:
                self.density_matrix = np.ones((909, 749))
            elif self.city == &#34;NewTown&#34;:
                self.density_matrix = np.ones((38, 38))
        elif self.city == &#34;Delft&#34;:
            try:
                if self.purge_cache:
                    raise FileNotFoundError
                self.density_matrix = np.load(&#34;env/database/delft/density_matrix.npy&#34;)
                #print(&#34;loading from db&#34;)

            except FileNotFoundError:
                picca2 = Image.open(self.url_pop)
                picca2 = picca2.convert(&#39;RGB&#39;)
                self.width, self.height = picca2.size  # obtaining dimensions of figure

                self.density_matrix = np.zeros((self.width, self.height))  # setting up the numpy array
                for i in range(0, self.width):
                    for j in range(0, self.height):

                        coordinates = i, j  # creating tuple as input of the next line
                        red, green, blue = picca2.getpixel(coordinates)  # obtaining the values of RGB for every pixel

                        # Pop density = pop/m^2, source = https://delft.incijfers.nl/jive?cat_show=Bevolking
                        if red &gt; 230 and green &gt; 230 and blue &gt; 230:  # assigning a value of 0 to all areas with no population density
                            self.density_matrix[i, j] = 0.01 / 100

                        elif red == 255 and green &gt; 195 and blue &gt; 150:  # assigning a value of 1 to all areas based on their population density
                            self.density_matrix[i, j] = 0.1 / 100

                        elif red == 244 and green == 156 and blue &gt; 5:  # assigning a value of 2 to all areas based on their population density
                            self.density_matrix[i, j] = 0.7 / 100

                        elif red == 231 and green == 77 and blue &gt; 20:  # assigning a value of 3 to all areas based on their population density
                            self.density_matrix[i, j] = 0.012

                        elif red == 192 and green == 31 and blue &gt; 35:  # assigning a value of 4 to all areas based on their population density
                            self.density_matrix[i, j] = 0.016

                        elif red == 130 and green &gt;= 0 and blue == 30:  # assigning a value of 5 to all areas based on their population density
                            self.density_matrix[i, j] = 0.023 #actual value: 23k citizens / km^2 (or 0.023 citizens per m^2)

                        else:  # assigning a cost of 0 to pixels that meet none of these if statements
                            self.density_matrix[i, j] = 0.01 / 100
                            self.density_matrix[i, j] = self.density_matrix[i][j - 1]

                #np.save(&#34;env/database/delft/density_matrix.npy&#34;, self.density_matrix)

            # self.density_matrix = self.density_matrix.transpose()
        elif self.city == &#34;NewYork&#34;:
            try:
                if self.purge_cache:
                    raise FileNotFoundError
                self.density_matrix = np.load(&#34;env/database/ny/density_matrix.npy&#34;)
                #print(&#34;loading from db&#34;)

            except FileNotFoundError:
                picca2 = Image.open(self.url_pop)
                picca2 = picca2.convert(&#39;RGB&#39;)
                self.width, self.height = picca2.size  # obtaining dimensions of figure

                self.density_matrix = np.zeros((self.width, self.height))  # setting up the numpy array
                for i in range(0, self.width):
                    for j in range(0, self.height):

                        coordinates = i, j  # creating tuple as input of the next line
                        red, green, blue = picca2.getpixel(coordinates)  # obtaining the values of RGB for every pixel

                        # Pop density = pop/m^2, source = https://delft.incijfers.nl/jive?cat_show=Bevolking
                        if red == 230 and green == 223 and blue == 20:  # Yellow, 30,000 - 150,000 ppl / square km
                            self.density_matrix[i, j] = 0.09

                        elif red == 93 and green == 69 and blue == 71:  # dark dark red (lowest ppl dens, 1,500 - 3,330 ppl / sq km)
                            self.density_matrix[i, j] = (1500 + 3300) / (2*1e6)

                        elif red == 167 and green == 28 and blue == 38:  # (dark)-red (3,330 - 7,000)
                            self.density_matrix[i, j] = (3330 + 7000) / (2*1e6)

                        elif red == 227 and green == 143 and blue == 64:  # orange, (7,000 - 30,000) ppl / sq KM
                            self.density_matrix[i, j] = (7000 + 30000)  / (2*1e6)

                        elif red == 35 and green == 34 and blue == 39:  # assigning a value of 4 to all areas based on their population density
                            self.density_matrix[i, j] = 0.0

                        elif red == 96 and green == 96 and blue == 99:  # assigning a value of 5 to all areas based on their population density
                            self.density_matrix[i, j] = 0.0 #actual value: 23k citizens / km^2 (or 0.023 citizens per m^2)

                        else:  # If a color is not matched, throw a warning, and take the average of the four surrounding points (
                            print(&#34;WARNING: Unmatched color in NY, color = ({}, {}, {})&#34;.format(red, green, blue))
                            self.density_matrix[i, j] = 0.25 * (self.density_matrix[i][j + 1] + self.density_matrix[i][j - 1] + self.density_matrix[i-1][j] + self.density_matrix[i+1][j])

                #np.save(&#34;env/database/newyork/density_matrix.npy&#34;, self.density_matrix)

        elif self.city == &#34;Paris&#34;:
            try:
                if self.purge_cache:
                    raise FileNotFoundError
                self.density_matrix = np.load(&#34;env/database/paris/density_matrix.npy&#34;)
                #print(&#34;loading from db&#34;)

            except FileNotFoundError:
                picca2 = Image.open(self.url_pop)
                picca2 = picca2.convert(&#39;RGB&#39;)
                self.width, self.height = picca2.size  # obtaining dimensions of figure

                self.density_matrix = np.zeros((self.width, self.height))  # setting up the numpy array
                for i in range(0, self.width):
                    for j in range(0, self.height):

                        coordinates = i, j  # creating tuple as input of the next line
                        red, green, blue = picca2.getpixel(coordinates)  # obtaining the values of RGB for every pixel

                        # Pop density = pop/m^2, source = https://delft.incijfers.nl/jive?cat_show=Bevolking
                        if red == 142 and green == 29 and blue == 24: #Dark-red = &gt; 50,000 per km^2 #8E1D18 (142, 29, 24)

                            self.density_matrix[i, j] = 50000 / 1e6

                        elif red == 197 and green == 50 and blue == 45:  # Red = 25,000 - 50,000 per km^2 #C5322D (197, 50, 45)
                            self.density_matrix[i, j] = (3*25000 + 50000) / (4*1e6)

                        elif red == 221 and green == 100 and blue == 73:  # Orange = 10,000-25,000 per km^2 #DD6449 (221, 100, 73)
                            self.density_matrix[i, j] = (3*10000 + 25000) / (4*1e6)

                        elif red == 223 and green == 140 and blue == 112:  # Semi-orange = 5,000 - 10,000 per km^2 #DF8C70 (223, 140, 112)
                            self.density_matrix[i, j] = (3*5000 + 10000)  / (4*1e6)

                        elif red == 206 and green == 212 and blue == 213:  # White = &lt;2,500 per km^2 #CED4D5 (206, 212, 213)
                            self.density_matrix[i, j] = (0 + 2500) / (2*1e6)

                        elif red == 95 and green == 144 and blue == 180:  # White = &lt;2,500 per km^2 #CED4D5 (206, 212, 213)
                            self.density_matrix[i, j] = 0.0

                        # elif red == 96 and green == 96 and blue == 99:  # assigning a value of 5 to all areas based on their population density
                        #     self.density_matrix[i, j] = 0.0 #actual value: 23k citizens / km^2 (or 0.023 citizens per m^2)

                        else:  # If a color is not matched, throw a warning, and take the average of the four surrounding points (
                            print(&#34;WARNING: Unmatched color in Paris, color = ({}, {}, {})&#34;.format(red, green, blue))
                            self.density_matrix[i, j] = 0.25 * (self.density_matrix[i][j + 1] + self.density_matrix[i][j - 1] + self.density_matrix[i-1][j] + self.density_matrix[i+1][j])

                #np.save(&#34;env/database/paris/density_matrix.npy&#34;, self.density_matrix)

        else:
            raise Exception(&#34;Unknown city&#34;)


    def loadShelteringData(self):
        &#39;&#39;&#39;
        Method that is ran whenever the loadEnvironment class is initialized. It loads the sheltering data of the current city.
        &#39;&#39;&#39;
        if self.city == &#34;CityGrid&#34;:
            self.generateCityGrid(block_width = 4, block_height=4, street_width=2, n_blocks_width=5, n_blocks_height=5, position_river=&#34;middle&#34;, width_river=2, n_block_river=2 )
            return

        if self.url_shelter == None:
            self.shelter_matrix = np.ones((909, 749))
            self.shelter_category = np.zeros((909, 749), dtype=int)
            self.shelter_category_names = np.array([&#34;Home Area&#34;])
        else:
            picca = Image.open(self.url_shelter)
            picca = picca.convert(&#39;RGB&#39;)
            width, height = picca.size  # obtaining dimensions of figure
            self.width = width
            self.height = height

            shelter_factor = np.zeros((width, height))  # setting up the numpy array
            self.isWater = np.zeros((width,height))
            self.shelter_category = np.zeros((width, height), dtype=int)
            unique_colors = []
            if self.city == &#34;NewTown&#34;:
                self.shelter_category_names = np.array(
                    [&#34;Error&#34;, &#34;Office&#34;, &#34;Water&#34;, &#34;Street&#34;, &#34;Event Location&#34;, &#34;Home Area&#34;, &#34;Small Street&#34;, &#34;Meadow&#34;])

                for i in range(0,width):
                    for j in range(0,height):
                        coordinates = i, j  # creating tuple as input of the next line
                        red, green, blue = picca.getpixel(coordinates)  # obtaining the values of RGB for every pixel

                        if red == 0 and green == 128 and blue == 0:
                            # A green pixel is a park / meadow so has 0 sheltering
                            self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Meadow&#34;)[0][0])
                            shelter_factor[i,j] = 0.001 # to avoid divide by zero errors
                        elif red == 0 and green == 0 and blue == 255:
                            # Blue = urban area, so 2.5 sheltering
                            self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Home Area&#34;)[0][0])
                            shelter_factor[i,j] = 5
                        elif red == 0 and green == 0 and blue == 0:
                            self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Street&#34;)[0][0])
                            # Road, so 1.5 sheltering
                            shelter_factor[i,j] = 2
                        elif red == 255 and green == 0 and blue == 0:
                            self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Office&#34;)[0][0])
                            shelter_factor[i,j] = 7.5
                        else:
                            print(&#34;Color not matched is {}&#34;.format((red, green, blue)))
                            raise Exception(&#34;One color is not matched&#34;)

            # For new delft
            # pink = (204, 57, 209) = office
            # blue = (19,0,245)     = water
            # yellow = (255,255,0) = street
            # red = (234, 51, 35)   = event location
            # black = (0,0,0)       = home area
            # white = (255,255,255) = small street
            # green = (55, 126, 34) = meadow


            elif self.city == &#34;Delft&#34;:
                self.shelter_category_names = np.array(
                    [&#34;Error&#34;, &#34;Office&#34;, &#34;Water&#34;, &#34;Street&#34;, &#34;Event Location&#34;, &#34;Home Area&#34;, &#34;Small Street&#34;, &#34;Meadow&#34;])
                shelter_cat_url = &#34;env/database/delft/shelter_category_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                isWater_url = &#34;env/database/delft/is_water_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                shelterMatrixUrl = &#34;env/database/delft/shelter_matrix_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                try:
                    if self.purge_cache:
                        raise FileNotFoundError
                    #print(&#34;loading from db&#34;)

                    self.shelter_category = np.load(shelter_cat_url)
                    self.isWater = np.load(isWater_url) # This is redundant!
                    self.shelter_matrix = np.load(shelterMatrixUrl)
                except FileNotFoundError:
                    for i in range(0, width):
                        for j in range(0, height):

                            coordinates = i, j  # creating tuple as input of the next line
                            red, green, blue = picca.getpixel(coordinates)  # obtaining the values of RGB for every pixel
                            color = (red,green,blue)

                            if red == 204 and green == 57 and blue == 209:  # Pink, office
                                shelter_factor[i, j] = 7.5
                                self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Office&#34;)[0][0])
                            elif red == 55 and green == 126 and blue == 34:
                                shelter_factor[i,j] = 0
                                self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Meadow&#34;)[0][0])
                            elif red == 19 and green == 0 and blue == 245:  # blue, water
                                shelter_factor[i, j] = 0
                                self.isWater[i,j] = 1
                                # print(&#34;categorising water at position {}&#34;.format((i,j)))
                                self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Water&#34;)[0][0])
                            elif red == 255 and green == 255 and blue == 0:  # yellow, street
                                shelter_factor[i, j] = 3.5
                                self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Street&#34;)[0][0])
                            elif red == 234 and green == 51 and blue == 35: # red, event location
                                shelter_factor[i,j] = 0
                                self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Event Location&#34;)[0][0])
                            elif red == 0 and green == 0 and blue == 0: # black, home location
                                shelter_factor[i,j] = 5
                                self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Home Area&#34;)[0][0])
                            elif red == 255 and green == 255 and blue == 255:
                                shelter_factor[i,j] = 2.5 # white, small roads
                                self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Small Street&#34;)[0][0])
                            else:
                                print(picca.getpixel(coordinates))
                                raise Exception(&#34;Pixel found in city Delft that can&#39;t be defined.&#34;)

                    if np.count_nonzero(self.shelter_category == 0) &gt; 0:
                            raise Exception(&#34;Not all gridpoints have been categorised&#34;)

                    # self.shelter_matrix = shelter_factor.transpose()  # for some reason, the array is sideways, here it gets transposed to the correct orientation
                    self.shelter_matrix = shelter_factor
                    self.shelter_matrix[self.shelter_matrix == 0] = 0.001

                    #np.save(shelter_cat_url, self.shelter_category)
                    #np.save(shelterMatrixUrl, self.shelter_matrix)
                    #np.save(isWater_url, self.isWater)

            elif self.city == &#34;NewYork&#34;:
                changedensmap = Image.open(self.url_modifyPopDens)
                changedensmap = changedensmap.convert(&#34;RGB&#34;)


                # 170, 218, 255 = blue = water
                # 199, 233, 199 = green = parks
                # 255, 234, 160 = large roads = yellow
                # 255, 255, 255 = white = roads
                # 232, 232, 232 = grey = residential
                # 254, 247, 224 = light yellow (office districts)
                # 252, 232, 230 = pink, hospital

                self.shelter_category_names = np.array(
                    [&#34;Error&#34;, &#34;Office&#34;, &#34;Water&#34;, &#34;Street&#34;, &#34;Event Location&#34;, &#34;Home Area&#34;, &#34;Small Street&#34;, &#34;Meadow&#34;])
                shelter_cat_url = &#34;env/database/newyork/shelter_category_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                isWater_url = &#34;env/database/newyork/is_water_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                shelterMatrixUrl = &#34;env/database/newyork/shelter_matrix_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                try:
                    if self.purge_cache:
                        raise FileNotFoundError
                    #print(&#34;loading from db&#34;)
                    self.shelter_category = np.load(shelter_cat_url)
                    self.isWater = np.load(isWater_url)  # This is redundant!
                    self.shelter_matrix = np.load(shelterMatrixUrl)
                except FileNotFoundError:
                    for i in range(0, width):
                        for j in range(0, height):
                            coordinates = i, j  # creating tuple as input of the next line
                            red, green, blue = picca.getpixel(
                                coordinates)  # obtaining the values of RGB for every pixel

                            red_cd, green_cd, blue_cd = changedensmap.getpixel(coordinates)

                            if red == 170 and green == 218 and blue == 255:  # blue, water
                                shelter_factor[i, j] = 0
                                self.isWater[i, j] = 1
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Water&#34;)[0][0])
                            elif red == 199 and green == 233 and blue == 199: # green, parks
                                shelter_factor[i, j] = 1
                                self.density_matrix[i, j] = 0
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Meadow&#34;)[0][0])
                            elif red == 255 and green == 234 and blue == 160:  # yellow
                                shelter_factor[i, j] = 2.5
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Street&#34;)[0][0])
                            elif red == 255 and green == 255 and blue == 255:  # white, small street
                                shelter_factor[i, j] = 2.5
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Small Street&#34;)[0][0])

                            elif (red == 253 and green == 246 and blue == 224) or (red == 232 and green == 232 and blue == 232) or (red == 252 and green == 232 and blue == 230):  # home / office area
                                if red_cd == 0 and green_cd == 0 and blue_cd == 0:
                                    shelter_factor[i, j] = 7.5 #offices
                                    self.shelter_category[i, j] = int(
                                        np.where(self.shelter_category_names == &#34;Office&#34;)[0][0])
                                else:
                                    shelter_factor[i, j] = 5
                                    self.shelter_category[i, j] = int(
                                        np.where(self.shelter_category_names == &#34;Home Area&#34;)[0][0])

                            else:
                                print(&#34;Color not accounted for rgb({}, {}, {})&#34;.format(red, green, blue))

                    self.shelter_matrix = shelter_factor
                    self.shelter_matrix[self.shelter_matrix == 0] = 0.001 # to avoid division by 0 errors
                    #np.save(shelter_cat_url, self.shelter_category)
                    #np.save(shelterMatrixUrl, self.shelter_matrix)
                    #np.save(isWater_url, self.isWater)

            elif self.city == &#34;Paris&#34;:
                # changedensmap = Image.open(self.url_modifyPopDens)
                # changedensmap = changedensmap.convert(&#34;RGB&#34;)

                # 170, 218, 255 = blue = water
                # 199, 233, 199 = green = parks
                # 255, 234, 160 = large roads = yellow
                # 255, 255, 255 = white = roads
                # 232, 232, 232 = grey = residential
                # 254, 247, 224 = light yellow (office districts)
                # 252, 232, 230 = pink, hospital

                self.shelter_category_names = np.array(
                    [&#34;Error&#34;, &#34;Office&#34;, &#34;Water&#34;, &#34;Street&#34;, &#34;Event Location&#34;, &#34;Home Area&#34;, &#34;Small Street&#34;, &#34;Meadow&#34;])
                shelter_cat_url = &#34;env/database/paris/shelter_category_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                isWater_url = &#34;env/database/paris/is_water_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                shelterMatrixUrl = &#34;env/database/paris/shelter_matrix_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                try:
                    if self.purge_cache:
                        raise FileNotFoundError
                    #print(&#34;loading from db&#34;)
                    self.shelter_category = np.load(shelter_cat_url)
                    self.isWater = np.load(isWater_url)  # This is redundant!
                    self.shelter_matrix = np.load(shelterMatrixUrl)
                except FileNotFoundError:
                    for i in range(0, width):
                        for j in range(0, height):
                            coordinates = i, j  # creating tuple as input of the next line
                            red, green, blue = picca.getpixel(
                                coordinates)  # obtaining the values of RGB for every pixel

                            # red_cd, green_cd, blue_cd = changedensmap.getpixel(coordinates)

                            if red == 170 and green == 218 and blue == 255:  # blue, water
                                shelter_factor[i, j] = 0
                                self.isWater[i, j] = 1
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Water&#34;)[0][0])
                            elif red == 199 and green == 233 and blue == 199: # green, parks
                                shelter_factor[i, j] = 0
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Meadow&#34;)[0][0])
                            elif red == 255 and green == 234 and blue == 160:  # yellow
                                shelter_factor[i, j] = 3.5
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Street&#34;)[0][0])
                            elif red == 255 and green == 255 and blue == 255:  # white, small street
                                shelter_factor[i, j] = 2.5
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Small Street&#34;)[0][0])

                            elif (red == 253 and green == 246 and blue == 224) or (red == 252 and green == 232 and blue == 230):
                                # pink = hospital = considered office
                                # light yellow = offices
                                shelter_factor[i, j] = 7.5  # offices
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Office&#34;)[0][0])

                            elif (red == 232 and green == 232 and blue == 232):  # home / office area
                                shelter_factor[i, j] = 5
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Home Area&#34;)[0][0])

                            else:
                                print(&#34;Color not accounted for rgb({}, {}, {})&#34;.format(red, green, blue))

                    self.shelter_matrix = shelter_factor
                    self.shelter_matrix[self.shelter_matrix == 0] = 0.001 # to avoid division by 0 errors
                    #np.save(shelter_cat_url, self.shelter_category)
                    #np.save(shelterMatrixUrl, self.shelter_matrix)
                    #np.save(isWater_url, self.isWater)

            else:
                raise Exception(&#34;Sheltering data is not defined for this city&#34;)



        # if self.scaling_method == &#34;Normal&#34;:
        #     self.Shelter_scaled = self.shelter_matrix[0:self.shelter_matrix.shape[0]:self.scaling_factor,
        #                           0:self.shelter_matrix.shape[1]:self.scaling_factor]
        #
        # elif self.scaling_method == &#34;Real_Average&#34;:
        #     width_scaled = math.ceil(self.shelter_matrix.shape[0] / self.scaling_factor)
        #     height_scaled = math.ceil
        #     self.Shelter_scaled = input()

    def removePopDensityFromWater(self):
        &#39;&#39;&#39;
        This method removes population density from water.
        &#39;&#39;&#39;
        # print(&#34;removing pop density from water&#34;)
        if self.city == &#34;Delft&#34; or self.city == &#34;NewYork&#34; or self.city == &#34;Paris&#34;:
            self.density_matrix[self.isWater == 1] = 0.0
            # self.shelter_matrix[self.isWater == 1] = 2.5
            if len(np.where(self.isWater)[0]) == 0:
                raise Exception(&#34;Trying to remove water, but there is no water&#34;)
            # print(&#34;Not removing water because city is {}&#34;.format(self.city))
            # raise Exception(&#34;Removing water is only available for Delft&#34;)
        else:
            print(&#34;Warning, function removePopDensityFromWater called but is not working&#34;)

    def modifyPopDensityWater(self):
        &#39;&#39;&#39;
        Method that is ran whenever the loadEnvironment class is initialized. It modifies the population density on water.
        &#39;&#39;&#39;
        if self.city == &#34;Delft&#34; or self.city == &#34;NewYork&#34; or self.city == &#34;Paris&#34;:
            # print(&#34;Modifying water&#34;)
            self.density_matrix[self.isWater == 1] = 0.01
            # self.shelter_matrix[self.isWater == 1] = 2.5
            if len(np.where(self.isWater)[0]) == 0:
                raise Exception(&#34;Trying to remove water, but there is no water&#34;)
        else:
            print(&#34;Warning, function modifyPopDensityWater called but is not working&#34;)



    def statisticsPopulationDensity(self, verbose=True):
        &#39;&#39;&#39;
        Outputs statistics of the distribution of people in a city.
        verbose: boolean, whether or not to print the statistics
        &#39;&#39;&#39;
        # if self.url_modifyPopDens == None:
        #     raise Exception(&#34;Cannot modify population density - no image given&#34;)
        # else:
        #     figure = Image.open(self.url_modifyPopDens)
        #     figure = figure.convert(&#39;RGB&#39;)

        width, height = self.density_matrix.shape  # obtaining dimensions of figure


        # CODE: 0 = home area, 1 = office area, 2 = transport area, 3 = other
        self.area_code = np.zeros((width, height))

        self.population_per_category = np.zeros((len(self.shelter_category_names)))

        self.area = self.grid_size_m_x * self.grid_size_m_y


        width_m = self.width_meters / self.density_matrix.shape[0]
        height_m = self.height_meters / self.density_matrix.shape[1]
        area_m = width_m * height_m

        total_pop = 0
        for i in range(0, width):
            for j in range(0, height):
                total_pop += area_m * self.density_matrix[i, j]

        if verbose:
            print(&#34;Total population of {} million people&#34;.format(total_pop/1e6))

        for i in range(len(self.area_per_shelter_category)):
            self.area_per_shelter_category[i] = np.count_nonzero(self.shelter_category == i)

        for i in range(0, width):
            for j in range(0, height):
                try:
                    self.population_per_category[self.shelter_category[i, j]] += self.density_matrix[i, j]
                except IndexError:
                    print(&#34;debug here&#34;)
        if abs(1 - sum(self.population_per_category) / sum(sum(self.density_matrix))) &gt; 0.0001:
            raise Exception(&#34;Not all population accounted for in the statistics.&#34;)

        if verbose:
            total_pop = sum(self.population_per_category)
            for idx, category in enumerate(self.shelter_category_names):
                relative_dens = self.population_per_category[idx] / self.area_per_shelter_category[idx]
                print(&#34;Population in category {} is {} (is {}% of total, relative density = {})&#34;.format(category, self.population_per_category[idx], 100*self.population_per_category[idx]/total_pop, relative_dens))


    def generateCityGrid(self, block_width, block_height, street_width, n_blocks_width, n_blocks_height, position_river=None, width_river=5, n_block_river=3):
        &#39;&#39;&#39;
        Method that can create a dummy city.
        &#39;&#39;&#39;

        self.shelter_category_names = np.array(
            [&#34;Error&#34;, &#34;Office&#34;, &#34;Water&#34;, &#34;Street&#34;, &#34;Event Location&#34;, &#34;Home Area&#34;, &#34;Small Street&#34;, &#34;Meadow&#34;])

        total_width = n_blocks_width * block_width + (n_blocks_width - 1) * street_width
        total_height = n_blocks_height * block_height + (n_blocks_height - 1) * street_width

        self.shelter_matrix = np.zeros((total_width, total_height))
        self.density_matrix = np.zeros_like(self.shelter_matrix)

        self.isWater = np.zeros((total_width, total_height))
        self.shelter_category = np.zeros((total_width, total_height), dtype=int)

        type_block = np.zeros((n_blocks_width, n_blocks_height))

        # This can be different in the future!
        type_block[1, 2] = type_block[3, 2] = 1 # meadows

        type_block[1, 1] = type_block[3, 1] = type_block[1, 3] = type_block[3, 3] = type_block[2, 1] = type_block[
            2, 3] = 2 #offices

        for i in range(0, n_blocks_width):
            start_x = 0 + i * (block_width + street_width)
            end_x = block_width + i * (block_width + street_width)
            for j in range(0, n_blocks_height):
                start_y = 0 + j * (block_height + street_width)
                end_y = block_height + j * (block_height + street_width)

                if type_block[i, j] == 1:
                    # category meadow
                    self.density_matrix[start_x:end_x, start_y:end_y] = 2
                    self.shelter_matrix[start_x:end_x, start_y:end_y] = 0.001
                    self.shelter_category[start_x:end_x, start_y:end_y] = int(np.where(self.shelter_category_names == &#34;Meadow&#34;)[0][0])
                elif type_block[i, j] == 2:
                    # category office
                    self.density_matrix[start_x:end_x, start_y:end_y] = 5
                    self.shelter_matrix[start_x:end_x, start_y:end_y] = 5
                    self.shelter_category[start_x:end_x, start_y:end_y] = int(np.where(self.shelter_category_names == &#34;Office&#34;)[0][0])
                elif type_block[i, j] == 0:
                    # category home
                    self.density_matrix[start_x:end_x, start_y:end_y] = 10
                    self.shelter_matrix[start_x:end_x, start_y:end_y] = 3.5
                    self.shelter_category[start_x:end_x, start_y:end_y] = int(np.where(self.shelter_category_names == &#34;Home Area&#34;)[0][0])

        self.shelter_matrix[self.shelter_category == 0] = 2 # TODO make this a better value
        self.density_matrix[self.shelter_category == 0] = 1 # TODO make this a better value
        self.shelter_category[self.shelter_category == 0] = int(np.where(self.shelter_category_names == &#34;Street&#34;)[0][0])

        if width_river &gt; 0:
            river = np.zeros((width_river, total_height))
            river_sheltering = np.ones_like(river) * 1e-6
            river_category = np.ones_like(river) * int(np.where(self.shelter_category_names == &#34;Water&#34;)[0][0])
            river_category = river_category.astype(int)
            start = int(0 + n_block_river * (block_width + street_width) - street_width / 2)

            if position_river == &#34;left&#34;:
                self.shelter_matrix = np.vstack((river_sheltering, self.shelter_matrix))
                self.density_matrix = np.vstack((river, self.density_matrix))
                self.shelter_category = np.vstack((river_category, self.shelter_category))

            elif position_river == &#34;right&#34;:
                self.shelter_matrix = np.vstack((self.shelter_matrix, river_sheltering))
                self.density_matrix = np.vstack((self.density_matrix, river))
                self.shelter_category = np.vstack((self.shelter_category, river_category))

            elif position_river == &#34;middle&#34;:
                self.shelter_matrix = np.vstack((self.shelter_matrix[0:start, :], river_sheltering, self.shelter_matrix[start:, :]))
                self.density_matrix = np.vstack((self.density_matrix[0:start, :], river, self.density_matrix[start:, :]))
                self.shelter_category = np.vstack((self.shelter_category[0:start, :], river_category, self.shelter_category[start:, :]))

            else:
                raise Exception(&#34;unknown position&#34;)



    def modifyPopulationDensity(self, target_array):
        &#39;&#39;&#39;
         Takes a target_array as input, which should be of the same length as shelter_category_names.
         It moves x % of the population to that area, so the total array should sum to 1.
        &#39;&#39;&#39;



        if len(target_array) != len(self.shelter_category_names):
            raise Exception(&#34;Modification array should be of same size as category names array&#34;)

        total_population = sum(sum(self.density_matrix))

        self.density_matrix_modified = np.zeros_like(self.density_matrix)


        # The weights-list should be pairwise multiplied with the area-size to find the constant

        pop_dens_constant = total_population / sum(np.multiply(self.area_per_shelter_category, target_array))

        for i in range(0, self.width):
            for j in range(0, self.height):
                self.density_matrix_modified[i,j] = target_array[self.shelter_category[i,j]] * pop_dens_constant

        # print(sum(sum(self.density_matrix_modified)) / total_population)

        new_total_population = sum(sum(self.density_matrix_modified))

        # print(&#34;Initial total pop = {}, final total pop = {}&#34;.format(total_population, new_total_population))

        diff_pop = abs((new_total_population / total_population) - 1)
        if diff_pop &gt; 0.05:
            raise Exception(&#34;Total population count changed more than 5% while moving people around - this can&#39;t be right!&#34;)

        if diff_pop &gt; 0.001:
            print(&#34;WARNING: Total population count changed by {}%&#34;.format(diff_pop*100))

        self.density_matrix = self.density_matrix_modified.copy()

    def scaleMap(self, na, scaling_factor, scaling_method=&#34;average&#34;, file_name=&#34;&#34;):
        &#39;&#39;&#39;

        @param na: numpy array of the map that is to be scaled
        @param scaling_factor: factor by which this map should be scaled
        @param scaling_method: method to use (mode / average)
        @param file_name: file name in which the map can be stored.
        @return:
        &#39;&#39;&#39;
        file_loc = &#34;env/database/scaled_maps/&#34; + &#34;c=&#34; + self.city + &#34;_n=&#34; + file_name + &#34;_s=&#34; + str(scaling_factor) + &#34;_m=&#34; + scaling_method + &#34;_ws=&#34; + str(self.waterSetting) + &#34;.npy&#34;
        try:
            if self.purge_cache:
                raise FileNotFoundError
            #print(&#34;loading from db&#34;)

            scaled_map = np.load(file_loc)
            #print(&#34;loading from db&#34;)
        except FileNotFoundError:
            if scaling_factor == 1:
                return na

            block_shape = (scaling_factor, scaling_factor)

            width_scaled = math.floor(na.shape[0] / block_shape[0])
            height_scaled = math.floor(na.shape[1] / block_shape[1])

            width_cropped = width_scaled * block_shape[0]
            height_cropped = height_scaled * block_shape[1]

            view = view_as_blocks(na[:width_cropped, :height_cropped], block_shape)
            flatView = view.reshape(view.shape[0], view.shape[1], -1)

            if scaling_method == &#34;average&#34;:
                scaled_map = np.average(flatView, axis=2)
            elif scaling_method == &#34;mode&#34;:
                scaled_map = stats.mode(flatView, axis=2)[0].reshape((width_scaled, height_scaled))
            elif scaling_method == &#34;original_AABMS&#34;:
                scaled_map = na[0:na.shape[0]:scaling_factor, 0:na.shape[1]:scaling_factor]
            else:
                raise Exception(&#34;Unknown scaling mode.&#34;)

            #np.save(file_loc, scaled_map)

        return scaled_map


if __name__ == &#34;__main__&#34;:
    &#39;&#39;&#39;
    Code here is only used for creating plots and evaluating whether the loadEnvironment class is working as it should.
    &#39;&#39;&#39;
    import matplotlib.pyplot as plt

    env = loadEnvironment(city=&#34;Paris&#34;, scaling_factor=1, risk_map_resolution=1, water_setting=0)

    beta = 34
    alpha = 32000
    width = env.shelter_matrix.shape[0]
    height = env.shelter_matrix.shape[1]
    value_table = np.zeros((width,height))
    &#39;&#39;&#39;Calculate the risk at each location&#39;&#39;&#39;
    for i in range(width):
        for j in range(height):
            ps = env.shelter_matrix[i, j]
            # Impact kinetic energy
            v_terminal = 50
            Eimp = 0.5 * 3 * v_terminal ** 2
            # alpha = 32000  # impact energy required for a fatality probability of 50% when ps = 6
            # beta = 34  # impact energy needed to cause a fatality when ps approaches zero

            # Falality probability
            k = min(1, pow((beta / Eimp), 3 / ps))
            value = pow((alpha / beta), 0.5) * pow((beta / Eimp), 3 / (ps))
            pf = (1 - k) / (1 - 2 * k + value)
            value = pf * env.density_matrix[i, j]  # density_matrix unit = people / m^2
            # The unit of value = the amount of people that would die, given an impact in this place
            value_table[i, j] = value

    &#39;&#39;&#39;Plot the shelter factors at each location&#39;&#39;&#39;
    plt.imshow(env.shelter_matrix.transpose())
    plt.colorbar()
    plt.savefig(&#34;shelterParis.png&#34;)
    plt.show()

    &#39;&#39;&#39;Plot the pop density at each location&#39;&#39;&#39;
    plt.imshow(env.density_matrix.transpose())
    plt.colorbar()
    plt.savefig(&#34;densityParis.png&#34;)
    plt.show()

    &#39;&#39;&#39;Plot the shelter factors at each location&#39;&#39;&#39;
    plt.imshow(value_table.transpose(), cmap=&#34;Reds&#34;)
    plt.colorbar()
    plt.savefig(&#34;riskParis.png&#34;)
    plt.show()


    env.statisticsPopulationDensity(verbose=True)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="github_version.env.loadEnvironment.loadEnvironment"><code class="flex name class">
<span>class <span class="ident">loadEnvironment</span></span>
<span>(</span><span>city='Delft', pop_dens_scenario=None, scaling_factor=1, risk_map_resolution=1, water_setting=0, modify_dens_list=[])</span>
</code></dt>
<dd>
<div class="desc"><p>The loadEnvironment class, which loads the cities
city: Chooses the city to load
scaling_factor: the factor by which all regular maps are scaled (this is used for path-finding)
risk_map_resolution: the factor by which all _risk maps are scaled (these are used for risk-computation)
water_setting: whether or not to remove all pop dens from water (0 = no pop dens on water)
modify_dens_list: accepts a list which can be used to modify pop density</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class loadEnvironment():
    def __init__(self, city=&#34;Delft&#34;, pop_dens_scenario=None, scaling_factor=1, risk_map_resolution=1, water_setting = 0, modify_dens_list = []):
        &#34;&#34;&#34;
        The loadEnvironment class, which loads the cities
        city: Chooses the city to load
        scaling_factor: the factor by which all regular maps are scaled (this is used for path-finding)
        risk_map_resolution: the factor by which all _risk maps are scaled (these are used for risk-computation)
        water_setting: whether or not to remove all pop dens from water (0 = no pop dens on water)
        modify_dens_list: accepts a list which can be used to modify pop density

        &#34;&#34;&#34;
        self.purge_cache = True
        self.waterSetting = water_setting
        self.url_pop = cities[city][&#34;url_pop&#34;]
        self.url_shelter = cities[city][&#34;url_shelter&#34;]
        self.url_modifyPopDens = cities[city][&#34;url_modifyPopDens&#34;]

        self.scaling_factor_normal = scaling_factor
        self.scaling_factor_risk = risk_map_resolution

        self.city = city

        self.width_meters = cities[city][&#34;width_meters&#34;]
        self.height_meters = cities[city][&#34;height_meters&#34;]

        # These two functions load all pop-, and sheltering-data
        self.loadPopulationDensity()
        self.loadShelteringData()
        self.shelter_matrix[self.shelter_matrix == 0] = 0.001


        self.shelter_category_names = np.append(self.shelter_category_names, &#34;hub&#34;)
        self.shelter_category_names = np.append(self.shelter_category_names, &#34;delivery point&#34;)


        # A function which has some statistics on how big the area of each category is.
        self.area_per_shelter_category = np.zeros((len(self.shelter_category_names)))
        for i in range(len(self.area_per_shelter_category)):
            self.area_per_shelter_category[i] = np.count_nonzero(self.shelter_category == i)


        # if pop_dens_scenario == &#34;working_hours&#34;:
        #     if self.city != &#34;Delft&#34;:
        #         raise Exception(&#34;Modifying pop density only supported for delft&#34;)
        #
        #     self.modifyPopulationDensity(target_home=0.0, target_office=(0.0), target_transport=1.0, target_other=0.0)
        #     self.density_matrix = self.densitymatrix_modified.copy()

        if water_setting == 1:
            self.modifyPopDensityWater()
        elif water_setting == 0 :
            self.removePopDensityFromWater() # TODO: This is undone by modifying pop density
        # else:
        #     print(&#34;WARNING: not doing anything with water as city is NY&#34;)


        # Usually: [&#39;Error&#39; &#39;Office&#39; &#39;Water&#39; &#39;Street&#39; &#39;Event Location&#39; &#39;Home Area&#39;, &#39;Small Street&#39; &#39;Meadow&#39;]
        if len(modify_dens_list) &gt; 0:
            self.modifyPopulationDensity(modify_dens_list) # Hub &amp; Deliverypoint are only appended later so therefore this is the correct size of the array.
            self.density_matrix = self.density_matrix_modified.copy()



        # In the following, all maps are scaled. For density-maps, &#34;average&#34; scaling has shown to be optimal,
        # while for sheltering, &#34;mode&#34; has shown to be optimal
        self.density_matrix_scaled = self.scaleMap(self.density_matrix, scaling_factor=self.scaling_factor_normal,
                                                   scaling_method=&#34;average&#34;, file_name=&#34;density_matrix_scaled&#34;)
        self.shelter_map_scaled = self.scaleMap(self.shelter_matrix, scaling_factor=self.scaling_factor_normal,
                                                scaling_method=&#34;mode&#34;, file_name=&#34;shelter_map_scaled&#34;)

        self.density_matrix_scaled_risk = self.scaleMap(self.density_matrix, scaling_factor=self.scaling_factor_risk,
                                                        scaling_method=&#34;average&#34;, file_name=&#34;density_matrix_scaled_risk&#34;)
        self.shelter_map_scaled_risk = self.scaleMap(self.shelter_matrix, scaling_factor=self.scaling_factor_risk,
                                                     scaling_method=&#34;mode&#34;, file_name=&#34;shelter_map_scaled_risk&#34;)

        self.shelter_category = self.shelter_category
        self.shelter_category_scaled = self.scaleMap(self.shelter_category, scaling_factor=self.scaling_factor_normal,
                                                           scaling_method=&#34;mode&#34;, file_name=&#34;shelter_category_scaled&#34;)  # TODO scale this appropriately for both risk and pathfinding

        self.shelter_category_scaled_risk = self.scaleMap(self.shelter_category, scaling_factor=self.scaling_factor_risk,
                                                                scaling_method=&#34;mode&#34;, file_name=&#34;shelter_category_scaled_risk&#34;)




        # Extract the parameters of the maps (sizes etc)
        self.Width = self.shelter_map_scaled.shape[0]
        self.Height = self.shelter_map_scaled.shape[1]
        self.width_risk = self.density_matrix_scaled_risk.shape[0]
        self.height_risk = self.density_matrix_scaled_risk.shape[1]

        self.width_risk_m = self.width_meters / self.width_risk
        self.height_risk_m = self.height_meters / self.height_risk

        self.risk_grid_size_m_x = self.width_meters / self.density_matrix_scaled_risk.shape[0]
        self.risk_grid_size_m_y = self.height_meters / self.density_matrix_scaled_risk.shape[1]

        self.grid_size_m_x = self.width_meters / self.density_matrix_scaled.shape[0]
        self.grid_size_m_y = self.height_meters / self.density_matrix_scaled.shape[1]

        self.area_risk_m = self.width_risk_m * self.height_risk_m

        self.statisticsPopulationDensity(verbose=False)  # This function is required for some other things

        if (self.density_matrix_scaled.shape != self.shelter_map_scaled.shape) or (self.density_matrix.shape != self.shelter_matrix.shape) or (
                self.density_matrix_scaled_risk.shape != self.shelter_map_scaled_risk.shape) or (self.shelter_category_scaled_risk.shape != self.density_matrix_scaled_risk.shape) or (self.shelter_category_scaled.shape != self.shelter_map_scaled.shape):
            raise Exception(&#34;Dimensions of density matrix and sheltering do not match&#34;)



        if self.density_matrix.shape != self.shelter_matrix.shape:
            raise Exception(&#34;Dimensions of Density Matrix and Sheltering Map differ&#34;)

        # elif self.densitymatrix_scaled.shape != self.Shelter_scaled.shape:
        #     print(self.densitymatrix_scaled.shape)
        #     print(self.Shelter_scaled.shape)
        #     # raise Exception(&#34;Dimensions of scaled Density Matrix and Sheltering Map differ&#34;)

    def loadPopulationDensity(self):
        &#39;&#39;&#39;
        Method that is ran whenever the loadEnvironment class is initialized. It loads the population density of the current city.
        &#39;&#39;&#39;
        if self.city == &#34;CityGrid&#34;:
            return
        if self.url_pop == None:
            if self.city == &#34;UniformTown&#34;:
                self.density_matrix = np.ones((909, 749))
            elif self.city == &#34;NewTown&#34;:
                self.density_matrix = np.ones((38, 38))
        elif self.city == &#34;Delft&#34;:
            try:
                if self.purge_cache:
                    raise FileNotFoundError
                self.density_matrix = np.load(&#34;env/database/delft/density_matrix.npy&#34;)
                #print(&#34;loading from db&#34;)

            except FileNotFoundError:
                picca2 = Image.open(self.url_pop)
                picca2 = picca2.convert(&#39;RGB&#39;)
                self.width, self.height = picca2.size  # obtaining dimensions of figure

                self.density_matrix = np.zeros((self.width, self.height))  # setting up the numpy array
                for i in range(0, self.width):
                    for j in range(0, self.height):

                        coordinates = i, j  # creating tuple as input of the next line
                        red, green, blue = picca2.getpixel(coordinates)  # obtaining the values of RGB for every pixel

                        # Pop density = pop/m^2, source = https://delft.incijfers.nl/jive?cat_show=Bevolking
                        if red &gt; 230 and green &gt; 230 and blue &gt; 230:  # assigning a value of 0 to all areas with no population density
                            self.density_matrix[i, j] = 0.01 / 100

                        elif red == 255 and green &gt; 195 and blue &gt; 150:  # assigning a value of 1 to all areas based on their population density
                            self.density_matrix[i, j] = 0.1 / 100

                        elif red == 244 and green == 156 and blue &gt; 5:  # assigning a value of 2 to all areas based on their population density
                            self.density_matrix[i, j] = 0.7 / 100

                        elif red == 231 and green == 77 and blue &gt; 20:  # assigning a value of 3 to all areas based on their population density
                            self.density_matrix[i, j] = 0.012

                        elif red == 192 and green == 31 and blue &gt; 35:  # assigning a value of 4 to all areas based on their population density
                            self.density_matrix[i, j] = 0.016

                        elif red == 130 and green &gt;= 0 and blue == 30:  # assigning a value of 5 to all areas based on their population density
                            self.density_matrix[i, j] = 0.023 #actual value: 23k citizens / km^2 (or 0.023 citizens per m^2)

                        else:  # assigning a cost of 0 to pixels that meet none of these if statements
                            self.density_matrix[i, j] = 0.01 / 100
                            self.density_matrix[i, j] = self.density_matrix[i][j - 1]

                #np.save(&#34;env/database/delft/density_matrix.npy&#34;, self.density_matrix)

            # self.density_matrix = self.density_matrix.transpose()
        elif self.city == &#34;NewYork&#34;:
            try:
                if self.purge_cache:
                    raise FileNotFoundError
                self.density_matrix = np.load(&#34;env/database/ny/density_matrix.npy&#34;)
                #print(&#34;loading from db&#34;)

            except FileNotFoundError:
                picca2 = Image.open(self.url_pop)
                picca2 = picca2.convert(&#39;RGB&#39;)
                self.width, self.height = picca2.size  # obtaining dimensions of figure

                self.density_matrix = np.zeros((self.width, self.height))  # setting up the numpy array
                for i in range(0, self.width):
                    for j in range(0, self.height):

                        coordinates = i, j  # creating tuple as input of the next line
                        red, green, blue = picca2.getpixel(coordinates)  # obtaining the values of RGB for every pixel

                        # Pop density = pop/m^2, source = https://delft.incijfers.nl/jive?cat_show=Bevolking
                        if red == 230 and green == 223 and blue == 20:  # Yellow, 30,000 - 150,000 ppl / square km
                            self.density_matrix[i, j] = 0.09

                        elif red == 93 and green == 69 and blue == 71:  # dark dark red (lowest ppl dens, 1,500 - 3,330 ppl / sq km)
                            self.density_matrix[i, j] = (1500 + 3300) / (2*1e6)

                        elif red == 167 and green == 28 and blue == 38:  # (dark)-red (3,330 - 7,000)
                            self.density_matrix[i, j] = (3330 + 7000) / (2*1e6)

                        elif red == 227 and green == 143 and blue == 64:  # orange, (7,000 - 30,000) ppl / sq KM
                            self.density_matrix[i, j] = (7000 + 30000)  / (2*1e6)

                        elif red == 35 and green == 34 and blue == 39:  # assigning a value of 4 to all areas based on their population density
                            self.density_matrix[i, j] = 0.0

                        elif red == 96 and green == 96 and blue == 99:  # assigning a value of 5 to all areas based on their population density
                            self.density_matrix[i, j] = 0.0 #actual value: 23k citizens / km^2 (or 0.023 citizens per m^2)

                        else:  # If a color is not matched, throw a warning, and take the average of the four surrounding points (
                            print(&#34;WARNING: Unmatched color in NY, color = ({}, {}, {})&#34;.format(red, green, blue))
                            self.density_matrix[i, j] = 0.25 * (self.density_matrix[i][j + 1] + self.density_matrix[i][j - 1] + self.density_matrix[i-1][j] + self.density_matrix[i+1][j])

                #np.save(&#34;env/database/newyork/density_matrix.npy&#34;, self.density_matrix)

        elif self.city == &#34;Paris&#34;:
            try:
                if self.purge_cache:
                    raise FileNotFoundError
                self.density_matrix = np.load(&#34;env/database/paris/density_matrix.npy&#34;)
                #print(&#34;loading from db&#34;)

            except FileNotFoundError:
                picca2 = Image.open(self.url_pop)
                picca2 = picca2.convert(&#39;RGB&#39;)
                self.width, self.height = picca2.size  # obtaining dimensions of figure

                self.density_matrix = np.zeros((self.width, self.height))  # setting up the numpy array
                for i in range(0, self.width):
                    for j in range(0, self.height):

                        coordinates = i, j  # creating tuple as input of the next line
                        red, green, blue = picca2.getpixel(coordinates)  # obtaining the values of RGB for every pixel

                        # Pop density = pop/m^2, source = https://delft.incijfers.nl/jive?cat_show=Bevolking
                        if red == 142 and green == 29 and blue == 24: #Dark-red = &gt; 50,000 per km^2 #8E1D18 (142, 29, 24)

                            self.density_matrix[i, j] = 50000 / 1e6

                        elif red == 197 and green == 50 and blue == 45:  # Red = 25,000 - 50,000 per km^2 #C5322D (197, 50, 45)
                            self.density_matrix[i, j] = (3*25000 + 50000) / (4*1e6)

                        elif red == 221 and green == 100 and blue == 73:  # Orange = 10,000-25,000 per km^2 #DD6449 (221, 100, 73)
                            self.density_matrix[i, j] = (3*10000 + 25000) / (4*1e6)

                        elif red == 223 and green == 140 and blue == 112:  # Semi-orange = 5,000 - 10,000 per km^2 #DF8C70 (223, 140, 112)
                            self.density_matrix[i, j] = (3*5000 + 10000)  / (4*1e6)

                        elif red == 206 and green == 212 and blue == 213:  # White = &lt;2,500 per km^2 #CED4D5 (206, 212, 213)
                            self.density_matrix[i, j] = (0 + 2500) / (2*1e6)

                        elif red == 95 and green == 144 and blue == 180:  # White = &lt;2,500 per km^2 #CED4D5 (206, 212, 213)
                            self.density_matrix[i, j] = 0.0

                        # elif red == 96 and green == 96 and blue == 99:  # assigning a value of 5 to all areas based on their population density
                        #     self.density_matrix[i, j] = 0.0 #actual value: 23k citizens / km^2 (or 0.023 citizens per m^2)

                        else:  # If a color is not matched, throw a warning, and take the average of the four surrounding points (
                            print(&#34;WARNING: Unmatched color in Paris, color = ({}, {}, {})&#34;.format(red, green, blue))
                            self.density_matrix[i, j] = 0.25 * (self.density_matrix[i][j + 1] + self.density_matrix[i][j - 1] + self.density_matrix[i-1][j] + self.density_matrix[i+1][j])

                #np.save(&#34;env/database/paris/density_matrix.npy&#34;, self.density_matrix)

        else:
            raise Exception(&#34;Unknown city&#34;)


    def loadShelteringData(self):
        &#39;&#39;&#39;
        Method that is ran whenever the loadEnvironment class is initialized. It loads the sheltering data of the current city.
        &#39;&#39;&#39;
        if self.city == &#34;CityGrid&#34;:
            self.generateCityGrid(block_width = 4, block_height=4, street_width=2, n_blocks_width=5, n_blocks_height=5, position_river=&#34;middle&#34;, width_river=2, n_block_river=2 )
            return

        if self.url_shelter == None:
            self.shelter_matrix = np.ones((909, 749))
            self.shelter_category = np.zeros((909, 749), dtype=int)
            self.shelter_category_names = np.array([&#34;Home Area&#34;])
        else:
            picca = Image.open(self.url_shelter)
            picca = picca.convert(&#39;RGB&#39;)
            width, height = picca.size  # obtaining dimensions of figure
            self.width = width
            self.height = height

            shelter_factor = np.zeros((width, height))  # setting up the numpy array
            self.isWater = np.zeros((width,height))
            self.shelter_category = np.zeros((width, height), dtype=int)
            unique_colors = []
            if self.city == &#34;NewTown&#34;:
                self.shelter_category_names = np.array(
                    [&#34;Error&#34;, &#34;Office&#34;, &#34;Water&#34;, &#34;Street&#34;, &#34;Event Location&#34;, &#34;Home Area&#34;, &#34;Small Street&#34;, &#34;Meadow&#34;])

                for i in range(0,width):
                    for j in range(0,height):
                        coordinates = i, j  # creating tuple as input of the next line
                        red, green, blue = picca.getpixel(coordinates)  # obtaining the values of RGB for every pixel

                        if red == 0 and green == 128 and blue == 0:
                            # A green pixel is a park / meadow so has 0 sheltering
                            self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Meadow&#34;)[0][0])
                            shelter_factor[i,j] = 0.001 # to avoid divide by zero errors
                        elif red == 0 and green == 0 and blue == 255:
                            # Blue = urban area, so 2.5 sheltering
                            self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Home Area&#34;)[0][0])
                            shelter_factor[i,j] = 5
                        elif red == 0 and green == 0 and blue == 0:
                            self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Street&#34;)[0][0])
                            # Road, so 1.5 sheltering
                            shelter_factor[i,j] = 2
                        elif red == 255 and green == 0 and blue == 0:
                            self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Office&#34;)[0][0])
                            shelter_factor[i,j] = 7.5
                        else:
                            print(&#34;Color not matched is {}&#34;.format((red, green, blue)))
                            raise Exception(&#34;One color is not matched&#34;)

            # For new delft
            # pink = (204, 57, 209) = office
            # blue = (19,0,245)     = water
            # yellow = (255,255,0) = street
            # red = (234, 51, 35)   = event location
            # black = (0,0,0)       = home area
            # white = (255,255,255) = small street
            # green = (55, 126, 34) = meadow


            elif self.city == &#34;Delft&#34;:
                self.shelter_category_names = np.array(
                    [&#34;Error&#34;, &#34;Office&#34;, &#34;Water&#34;, &#34;Street&#34;, &#34;Event Location&#34;, &#34;Home Area&#34;, &#34;Small Street&#34;, &#34;Meadow&#34;])
                shelter_cat_url = &#34;env/database/delft/shelter_category_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                isWater_url = &#34;env/database/delft/is_water_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                shelterMatrixUrl = &#34;env/database/delft/shelter_matrix_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                try:
                    if self.purge_cache:
                        raise FileNotFoundError
                    #print(&#34;loading from db&#34;)

                    self.shelter_category = np.load(shelter_cat_url)
                    self.isWater = np.load(isWater_url) # This is redundant!
                    self.shelter_matrix = np.load(shelterMatrixUrl)
                except FileNotFoundError:
                    for i in range(0, width):
                        for j in range(0, height):

                            coordinates = i, j  # creating tuple as input of the next line
                            red, green, blue = picca.getpixel(coordinates)  # obtaining the values of RGB for every pixel
                            color = (red,green,blue)

                            if red == 204 and green == 57 and blue == 209:  # Pink, office
                                shelter_factor[i, j] = 7.5
                                self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Office&#34;)[0][0])
                            elif red == 55 and green == 126 and blue == 34:
                                shelter_factor[i,j] = 0
                                self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Meadow&#34;)[0][0])
                            elif red == 19 and green == 0 and blue == 245:  # blue, water
                                shelter_factor[i, j] = 0
                                self.isWater[i,j] = 1
                                # print(&#34;categorising water at position {}&#34;.format((i,j)))
                                self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Water&#34;)[0][0])
                            elif red == 255 and green == 255 and blue == 0:  # yellow, street
                                shelter_factor[i, j] = 3.5
                                self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Street&#34;)[0][0])
                            elif red == 234 and green == 51 and blue == 35: # red, event location
                                shelter_factor[i,j] = 0
                                self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Event Location&#34;)[0][0])
                            elif red == 0 and green == 0 and blue == 0: # black, home location
                                shelter_factor[i,j] = 5
                                self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Home Area&#34;)[0][0])
                            elif red == 255 and green == 255 and blue == 255:
                                shelter_factor[i,j] = 2.5 # white, small roads
                                self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Small Street&#34;)[0][0])
                            else:
                                print(picca.getpixel(coordinates))
                                raise Exception(&#34;Pixel found in city Delft that can&#39;t be defined.&#34;)

                    if np.count_nonzero(self.shelter_category == 0) &gt; 0:
                            raise Exception(&#34;Not all gridpoints have been categorised&#34;)

                    # self.shelter_matrix = shelter_factor.transpose()  # for some reason, the array is sideways, here it gets transposed to the correct orientation
                    self.shelter_matrix = shelter_factor
                    self.shelter_matrix[self.shelter_matrix == 0] = 0.001

                    #np.save(shelter_cat_url, self.shelter_category)
                    #np.save(shelterMatrixUrl, self.shelter_matrix)
                    #np.save(isWater_url, self.isWater)

            elif self.city == &#34;NewYork&#34;:
                changedensmap = Image.open(self.url_modifyPopDens)
                changedensmap = changedensmap.convert(&#34;RGB&#34;)


                # 170, 218, 255 = blue = water
                # 199, 233, 199 = green = parks
                # 255, 234, 160 = large roads = yellow
                # 255, 255, 255 = white = roads
                # 232, 232, 232 = grey = residential
                # 254, 247, 224 = light yellow (office districts)
                # 252, 232, 230 = pink, hospital

                self.shelter_category_names = np.array(
                    [&#34;Error&#34;, &#34;Office&#34;, &#34;Water&#34;, &#34;Street&#34;, &#34;Event Location&#34;, &#34;Home Area&#34;, &#34;Small Street&#34;, &#34;Meadow&#34;])
                shelter_cat_url = &#34;env/database/newyork/shelter_category_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                isWater_url = &#34;env/database/newyork/is_water_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                shelterMatrixUrl = &#34;env/database/newyork/shelter_matrix_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                try:
                    if self.purge_cache:
                        raise FileNotFoundError
                    #print(&#34;loading from db&#34;)
                    self.shelter_category = np.load(shelter_cat_url)
                    self.isWater = np.load(isWater_url)  # This is redundant!
                    self.shelter_matrix = np.load(shelterMatrixUrl)
                except FileNotFoundError:
                    for i in range(0, width):
                        for j in range(0, height):
                            coordinates = i, j  # creating tuple as input of the next line
                            red, green, blue = picca.getpixel(
                                coordinates)  # obtaining the values of RGB for every pixel

                            red_cd, green_cd, blue_cd = changedensmap.getpixel(coordinates)

                            if red == 170 and green == 218 and blue == 255:  # blue, water
                                shelter_factor[i, j] = 0
                                self.isWater[i, j] = 1
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Water&#34;)[0][0])
                            elif red == 199 and green == 233 and blue == 199: # green, parks
                                shelter_factor[i, j] = 1
                                self.density_matrix[i, j] = 0
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Meadow&#34;)[0][0])
                            elif red == 255 and green == 234 and blue == 160:  # yellow
                                shelter_factor[i, j] = 2.5
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Street&#34;)[0][0])
                            elif red == 255 and green == 255 and blue == 255:  # white, small street
                                shelter_factor[i, j] = 2.5
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Small Street&#34;)[0][0])

                            elif (red == 253 and green == 246 and blue == 224) or (red == 232 and green == 232 and blue == 232) or (red == 252 and green == 232 and blue == 230):  # home / office area
                                if red_cd == 0 and green_cd == 0 and blue_cd == 0:
                                    shelter_factor[i, j] = 7.5 #offices
                                    self.shelter_category[i, j] = int(
                                        np.where(self.shelter_category_names == &#34;Office&#34;)[0][0])
                                else:
                                    shelter_factor[i, j] = 5
                                    self.shelter_category[i, j] = int(
                                        np.where(self.shelter_category_names == &#34;Home Area&#34;)[0][0])

                            else:
                                print(&#34;Color not accounted for rgb({}, {}, {})&#34;.format(red, green, blue))

                    self.shelter_matrix = shelter_factor
                    self.shelter_matrix[self.shelter_matrix == 0] = 0.001 # to avoid division by 0 errors
                    #np.save(shelter_cat_url, self.shelter_category)
                    #np.save(shelterMatrixUrl, self.shelter_matrix)
                    #np.save(isWater_url, self.isWater)

            elif self.city == &#34;Paris&#34;:
                # changedensmap = Image.open(self.url_modifyPopDens)
                # changedensmap = changedensmap.convert(&#34;RGB&#34;)

                # 170, 218, 255 = blue = water
                # 199, 233, 199 = green = parks
                # 255, 234, 160 = large roads = yellow
                # 255, 255, 255 = white = roads
                # 232, 232, 232 = grey = residential
                # 254, 247, 224 = light yellow (office districts)
                # 252, 232, 230 = pink, hospital

                self.shelter_category_names = np.array(
                    [&#34;Error&#34;, &#34;Office&#34;, &#34;Water&#34;, &#34;Street&#34;, &#34;Event Location&#34;, &#34;Home Area&#34;, &#34;Small Street&#34;, &#34;Meadow&#34;])
                shelter_cat_url = &#34;env/database/paris/shelter_category_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                isWater_url = &#34;env/database/paris/is_water_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                shelterMatrixUrl = &#34;env/database/paris/shelter_matrix_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
                try:
                    if self.purge_cache:
                        raise FileNotFoundError
                    #print(&#34;loading from db&#34;)
                    self.shelter_category = np.load(shelter_cat_url)
                    self.isWater = np.load(isWater_url)  # This is redundant!
                    self.shelter_matrix = np.load(shelterMatrixUrl)
                except FileNotFoundError:
                    for i in range(0, width):
                        for j in range(0, height):
                            coordinates = i, j  # creating tuple as input of the next line
                            red, green, blue = picca.getpixel(
                                coordinates)  # obtaining the values of RGB for every pixel

                            # red_cd, green_cd, blue_cd = changedensmap.getpixel(coordinates)

                            if red == 170 and green == 218 and blue == 255:  # blue, water
                                shelter_factor[i, j] = 0
                                self.isWater[i, j] = 1
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Water&#34;)[0][0])
                            elif red == 199 and green == 233 and blue == 199: # green, parks
                                shelter_factor[i, j] = 0
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Meadow&#34;)[0][0])
                            elif red == 255 and green == 234 and blue == 160:  # yellow
                                shelter_factor[i, j] = 3.5
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Street&#34;)[0][0])
                            elif red == 255 and green == 255 and blue == 255:  # white, small street
                                shelter_factor[i, j] = 2.5
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Small Street&#34;)[0][0])

                            elif (red == 253 and green == 246 and blue == 224) or (red == 252 and green == 232 and blue == 230):
                                # pink = hospital = considered office
                                # light yellow = offices
                                shelter_factor[i, j] = 7.5  # offices
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Office&#34;)[0][0])

                            elif (red == 232 and green == 232 and blue == 232):  # home / office area
                                shelter_factor[i, j] = 5
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Home Area&#34;)[0][0])

                            else:
                                print(&#34;Color not accounted for rgb({}, {}, {})&#34;.format(red, green, blue))

                    self.shelter_matrix = shelter_factor
                    self.shelter_matrix[self.shelter_matrix == 0] = 0.001 # to avoid division by 0 errors
                    #np.save(shelter_cat_url, self.shelter_category)
                    #np.save(shelterMatrixUrl, self.shelter_matrix)
                    #np.save(isWater_url, self.isWater)

            else:
                raise Exception(&#34;Sheltering data is not defined for this city&#34;)



        # if self.scaling_method == &#34;Normal&#34;:
        #     self.Shelter_scaled = self.shelter_matrix[0:self.shelter_matrix.shape[0]:self.scaling_factor,
        #                           0:self.shelter_matrix.shape[1]:self.scaling_factor]
        #
        # elif self.scaling_method == &#34;Real_Average&#34;:
        #     width_scaled = math.ceil(self.shelter_matrix.shape[0] / self.scaling_factor)
        #     height_scaled = math.ceil
        #     self.Shelter_scaled = input()

    def removePopDensityFromWater(self):
        &#39;&#39;&#39;
        This method removes population density from water.
        &#39;&#39;&#39;
        # print(&#34;removing pop density from water&#34;)
        if self.city == &#34;Delft&#34; or self.city == &#34;NewYork&#34; or self.city == &#34;Paris&#34;:
            self.density_matrix[self.isWater == 1] = 0.0
            # self.shelter_matrix[self.isWater == 1] = 2.5
            if len(np.where(self.isWater)[0]) == 0:
                raise Exception(&#34;Trying to remove water, but there is no water&#34;)
            # print(&#34;Not removing water because city is {}&#34;.format(self.city))
            # raise Exception(&#34;Removing water is only available for Delft&#34;)
        else:
            print(&#34;Warning, function removePopDensityFromWater called but is not working&#34;)

    def modifyPopDensityWater(self):
        &#39;&#39;&#39;
        Method that is ran whenever the loadEnvironment class is initialized. It modifies the population density on water.
        &#39;&#39;&#39;
        if self.city == &#34;Delft&#34; or self.city == &#34;NewYork&#34; or self.city == &#34;Paris&#34;:
            # print(&#34;Modifying water&#34;)
            self.density_matrix[self.isWater == 1] = 0.01
            # self.shelter_matrix[self.isWater == 1] = 2.5
            if len(np.where(self.isWater)[0]) == 0:
                raise Exception(&#34;Trying to remove water, but there is no water&#34;)
        else:
            print(&#34;Warning, function modifyPopDensityWater called but is not working&#34;)



    def statisticsPopulationDensity(self, verbose=True):
        &#39;&#39;&#39;
        Outputs statistics of the distribution of people in a city.
        verbose: boolean, whether or not to print the statistics
        &#39;&#39;&#39;
        # if self.url_modifyPopDens == None:
        #     raise Exception(&#34;Cannot modify population density - no image given&#34;)
        # else:
        #     figure = Image.open(self.url_modifyPopDens)
        #     figure = figure.convert(&#39;RGB&#39;)

        width, height = self.density_matrix.shape  # obtaining dimensions of figure


        # CODE: 0 = home area, 1 = office area, 2 = transport area, 3 = other
        self.area_code = np.zeros((width, height))

        self.population_per_category = np.zeros((len(self.shelter_category_names)))

        self.area = self.grid_size_m_x * self.grid_size_m_y


        width_m = self.width_meters / self.density_matrix.shape[0]
        height_m = self.height_meters / self.density_matrix.shape[1]
        area_m = width_m * height_m

        total_pop = 0
        for i in range(0, width):
            for j in range(0, height):
                total_pop += area_m * self.density_matrix[i, j]

        if verbose:
            print(&#34;Total population of {} million people&#34;.format(total_pop/1e6))

        for i in range(len(self.area_per_shelter_category)):
            self.area_per_shelter_category[i] = np.count_nonzero(self.shelter_category == i)

        for i in range(0, width):
            for j in range(0, height):
                try:
                    self.population_per_category[self.shelter_category[i, j]] += self.density_matrix[i, j]
                except IndexError:
                    print(&#34;debug here&#34;)
        if abs(1 - sum(self.population_per_category) / sum(sum(self.density_matrix))) &gt; 0.0001:
            raise Exception(&#34;Not all population accounted for in the statistics.&#34;)

        if verbose:
            total_pop = sum(self.population_per_category)
            for idx, category in enumerate(self.shelter_category_names):
                relative_dens = self.population_per_category[idx] / self.area_per_shelter_category[idx]
                print(&#34;Population in category {} is {} (is {}% of total, relative density = {})&#34;.format(category, self.population_per_category[idx], 100*self.population_per_category[idx]/total_pop, relative_dens))


    def generateCityGrid(self, block_width, block_height, street_width, n_blocks_width, n_blocks_height, position_river=None, width_river=5, n_block_river=3):
        &#39;&#39;&#39;
        Method that can create a dummy city.
        &#39;&#39;&#39;

        self.shelter_category_names = np.array(
            [&#34;Error&#34;, &#34;Office&#34;, &#34;Water&#34;, &#34;Street&#34;, &#34;Event Location&#34;, &#34;Home Area&#34;, &#34;Small Street&#34;, &#34;Meadow&#34;])

        total_width = n_blocks_width * block_width + (n_blocks_width - 1) * street_width
        total_height = n_blocks_height * block_height + (n_blocks_height - 1) * street_width

        self.shelter_matrix = np.zeros((total_width, total_height))
        self.density_matrix = np.zeros_like(self.shelter_matrix)

        self.isWater = np.zeros((total_width, total_height))
        self.shelter_category = np.zeros((total_width, total_height), dtype=int)

        type_block = np.zeros((n_blocks_width, n_blocks_height))

        # This can be different in the future!
        type_block[1, 2] = type_block[3, 2] = 1 # meadows

        type_block[1, 1] = type_block[3, 1] = type_block[1, 3] = type_block[3, 3] = type_block[2, 1] = type_block[
            2, 3] = 2 #offices

        for i in range(0, n_blocks_width):
            start_x = 0 + i * (block_width + street_width)
            end_x = block_width + i * (block_width + street_width)
            for j in range(0, n_blocks_height):
                start_y = 0 + j * (block_height + street_width)
                end_y = block_height + j * (block_height + street_width)

                if type_block[i, j] == 1:
                    # category meadow
                    self.density_matrix[start_x:end_x, start_y:end_y] = 2
                    self.shelter_matrix[start_x:end_x, start_y:end_y] = 0.001
                    self.shelter_category[start_x:end_x, start_y:end_y] = int(np.where(self.shelter_category_names == &#34;Meadow&#34;)[0][0])
                elif type_block[i, j] == 2:
                    # category office
                    self.density_matrix[start_x:end_x, start_y:end_y] = 5
                    self.shelter_matrix[start_x:end_x, start_y:end_y] = 5
                    self.shelter_category[start_x:end_x, start_y:end_y] = int(np.where(self.shelter_category_names == &#34;Office&#34;)[0][0])
                elif type_block[i, j] == 0:
                    # category home
                    self.density_matrix[start_x:end_x, start_y:end_y] = 10
                    self.shelter_matrix[start_x:end_x, start_y:end_y] = 3.5
                    self.shelter_category[start_x:end_x, start_y:end_y] = int(np.where(self.shelter_category_names == &#34;Home Area&#34;)[0][0])

        self.shelter_matrix[self.shelter_category == 0] = 2 # TODO make this a better value
        self.density_matrix[self.shelter_category == 0] = 1 # TODO make this a better value
        self.shelter_category[self.shelter_category == 0] = int(np.where(self.shelter_category_names == &#34;Street&#34;)[0][0])

        if width_river &gt; 0:
            river = np.zeros((width_river, total_height))
            river_sheltering = np.ones_like(river) * 1e-6
            river_category = np.ones_like(river) * int(np.where(self.shelter_category_names == &#34;Water&#34;)[0][0])
            river_category = river_category.astype(int)
            start = int(0 + n_block_river * (block_width + street_width) - street_width / 2)

            if position_river == &#34;left&#34;:
                self.shelter_matrix = np.vstack((river_sheltering, self.shelter_matrix))
                self.density_matrix = np.vstack((river, self.density_matrix))
                self.shelter_category = np.vstack((river_category, self.shelter_category))

            elif position_river == &#34;right&#34;:
                self.shelter_matrix = np.vstack((self.shelter_matrix, river_sheltering))
                self.density_matrix = np.vstack((self.density_matrix, river))
                self.shelter_category = np.vstack((self.shelter_category, river_category))

            elif position_river == &#34;middle&#34;:
                self.shelter_matrix = np.vstack((self.shelter_matrix[0:start, :], river_sheltering, self.shelter_matrix[start:, :]))
                self.density_matrix = np.vstack((self.density_matrix[0:start, :], river, self.density_matrix[start:, :]))
                self.shelter_category = np.vstack((self.shelter_category[0:start, :], river_category, self.shelter_category[start:, :]))

            else:
                raise Exception(&#34;unknown position&#34;)



    def modifyPopulationDensity(self, target_array):
        &#39;&#39;&#39;
         Takes a target_array as input, which should be of the same length as shelter_category_names.
         It moves x % of the population to that area, so the total array should sum to 1.
        &#39;&#39;&#39;



        if len(target_array) != len(self.shelter_category_names):
            raise Exception(&#34;Modification array should be of same size as category names array&#34;)

        total_population = sum(sum(self.density_matrix))

        self.density_matrix_modified = np.zeros_like(self.density_matrix)


        # The weights-list should be pairwise multiplied with the area-size to find the constant

        pop_dens_constant = total_population / sum(np.multiply(self.area_per_shelter_category, target_array))

        for i in range(0, self.width):
            for j in range(0, self.height):
                self.density_matrix_modified[i,j] = target_array[self.shelter_category[i,j]] * pop_dens_constant

        # print(sum(sum(self.density_matrix_modified)) / total_population)

        new_total_population = sum(sum(self.density_matrix_modified))

        # print(&#34;Initial total pop = {}, final total pop = {}&#34;.format(total_population, new_total_population))

        diff_pop = abs((new_total_population / total_population) - 1)
        if diff_pop &gt; 0.05:
            raise Exception(&#34;Total population count changed more than 5% while moving people around - this can&#39;t be right!&#34;)

        if diff_pop &gt; 0.001:
            print(&#34;WARNING: Total population count changed by {}%&#34;.format(diff_pop*100))

        self.density_matrix = self.density_matrix_modified.copy()

    def scaleMap(self, na, scaling_factor, scaling_method=&#34;average&#34;, file_name=&#34;&#34;):
        &#39;&#39;&#39;

        @param na: numpy array of the map that is to be scaled
        @param scaling_factor: factor by which this map should be scaled
        @param scaling_method: method to use (mode / average)
        @param file_name: file name in which the map can be stored.
        @return:
        &#39;&#39;&#39;
        file_loc = &#34;env/database/scaled_maps/&#34; + &#34;c=&#34; + self.city + &#34;_n=&#34; + file_name + &#34;_s=&#34; + str(scaling_factor) + &#34;_m=&#34; + scaling_method + &#34;_ws=&#34; + str(self.waterSetting) + &#34;.npy&#34;
        try:
            if self.purge_cache:
                raise FileNotFoundError
            #print(&#34;loading from db&#34;)

            scaled_map = np.load(file_loc)
            #print(&#34;loading from db&#34;)
        except FileNotFoundError:
            if scaling_factor == 1:
                return na

            block_shape = (scaling_factor, scaling_factor)

            width_scaled = math.floor(na.shape[0] / block_shape[0])
            height_scaled = math.floor(na.shape[1] / block_shape[1])

            width_cropped = width_scaled * block_shape[0]
            height_cropped = height_scaled * block_shape[1]

            view = view_as_blocks(na[:width_cropped, :height_cropped], block_shape)
            flatView = view.reshape(view.shape[0], view.shape[1], -1)

            if scaling_method == &#34;average&#34;:
                scaled_map = np.average(flatView, axis=2)
            elif scaling_method == &#34;mode&#34;:
                scaled_map = stats.mode(flatView, axis=2)[0].reshape((width_scaled, height_scaled))
            elif scaling_method == &#34;original_AABMS&#34;:
                scaled_map = na[0:na.shape[0]:scaling_factor, 0:na.shape[1]:scaling_factor]
            else:
                raise Exception(&#34;Unknown scaling mode.&#34;)

            #np.save(file_loc, scaled_map)

        return scaled_map</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="github_version.env.loadEnvironment.loadEnvironment.generateCityGrid"><code class="name flex">
<span>def <span class="ident">generateCityGrid</span></span>(<span>self, block_width, block_height, street_width, n_blocks_width, n_blocks_height, position_river=None, width_river=5, n_block_river=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that can create a dummy city.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generateCityGrid(self, block_width, block_height, street_width, n_blocks_width, n_blocks_height, position_river=None, width_river=5, n_block_river=3):
    &#39;&#39;&#39;
    Method that can create a dummy city.
    &#39;&#39;&#39;

    self.shelter_category_names = np.array(
        [&#34;Error&#34;, &#34;Office&#34;, &#34;Water&#34;, &#34;Street&#34;, &#34;Event Location&#34;, &#34;Home Area&#34;, &#34;Small Street&#34;, &#34;Meadow&#34;])

    total_width = n_blocks_width * block_width + (n_blocks_width - 1) * street_width
    total_height = n_blocks_height * block_height + (n_blocks_height - 1) * street_width

    self.shelter_matrix = np.zeros((total_width, total_height))
    self.density_matrix = np.zeros_like(self.shelter_matrix)

    self.isWater = np.zeros((total_width, total_height))
    self.shelter_category = np.zeros((total_width, total_height), dtype=int)

    type_block = np.zeros((n_blocks_width, n_blocks_height))

    # This can be different in the future!
    type_block[1, 2] = type_block[3, 2] = 1 # meadows

    type_block[1, 1] = type_block[3, 1] = type_block[1, 3] = type_block[3, 3] = type_block[2, 1] = type_block[
        2, 3] = 2 #offices

    for i in range(0, n_blocks_width):
        start_x = 0 + i * (block_width + street_width)
        end_x = block_width + i * (block_width + street_width)
        for j in range(0, n_blocks_height):
            start_y = 0 + j * (block_height + street_width)
            end_y = block_height + j * (block_height + street_width)

            if type_block[i, j] == 1:
                # category meadow
                self.density_matrix[start_x:end_x, start_y:end_y] = 2
                self.shelter_matrix[start_x:end_x, start_y:end_y] = 0.001
                self.shelter_category[start_x:end_x, start_y:end_y] = int(np.where(self.shelter_category_names == &#34;Meadow&#34;)[0][0])
            elif type_block[i, j] == 2:
                # category office
                self.density_matrix[start_x:end_x, start_y:end_y] = 5
                self.shelter_matrix[start_x:end_x, start_y:end_y] = 5
                self.shelter_category[start_x:end_x, start_y:end_y] = int(np.where(self.shelter_category_names == &#34;Office&#34;)[0][0])
            elif type_block[i, j] == 0:
                # category home
                self.density_matrix[start_x:end_x, start_y:end_y] = 10
                self.shelter_matrix[start_x:end_x, start_y:end_y] = 3.5
                self.shelter_category[start_x:end_x, start_y:end_y] = int(np.where(self.shelter_category_names == &#34;Home Area&#34;)[0][0])

    self.shelter_matrix[self.shelter_category == 0] = 2 # TODO make this a better value
    self.density_matrix[self.shelter_category == 0] = 1 # TODO make this a better value
    self.shelter_category[self.shelter_category == 0] = int(np.where(self.shelter_category_names == &#34;Street&#34;)[0][0])

    if width_river &gt; 0:
        river = np.zeros((width_river, total_height))
        river_sheltering = np.ones_like(river) * 1e-6
        river_category = np.ones_like(river) * int(np.where(self.shelter_category_names == &#34;Water&#34;)[0][0])
        river_category = river_category.astype(int)
        start = int(0 + n_block_river * (block_width + street_width) - street_width / 2)

        if position_river == &#34;left&#34;:
            self.shelter_matrix = np.vstack((river_sheltering, self.shelter_matrix))
            self.density_matrix = np.vstack((river, self.density_matrix))
            self.shelter_category = np.vstack((river_category, self.shelter_category))

        elif position_river == &#34;right&#34;:
            self.shelter_matrix = np.vstack((self.shelter_matrix, river_sheltering))
            self.density_matrix = np.vstack((self.density_matrix, river))
            self.shelter_category = np.vstack((self.shelter_category, river_category))

        elif position_river == &#34;middle&#34;:
            self.shelter_matrix = np.vstack((self.shelter_matrix[0:start, :], river_sheltering, self.shelter_matrix[start:, :]))
            self.density_matrix = np.vstack((self.density_matrix[0:start, :], river, self.density_matrix[start:, :]))
            self.shelter_category = np.vstack((self.shelter_category[0:start, :], river_category, self.shelter_category[start:, :]))

        else:
            raise Exception(&#34;unknown position&#34;)</code></pre>
</details>
</dd>
<dt id="github_version.env.loadEnvironment.loadEnvironment.loadPopulationDensity"><code class="name flex">
<span>def <span class="ident">loadPopulationDensity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that is ran whenever the loadEnvironment class is initialized. It loads the population density of the current city.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadPopulationDensity(self):
    &#39;&#39;&#39;
    Method that is ran whenever the loadEnvironment class is initialized. It loads the population density of the current city.
    &#39;&#39;&#39;
    if self.city == &#34;CityGrid&#34;:
        return
    if self.url_pop == None:
        if self.city == &#34;UniformTown&#34;:
            self.density_matrix = np.ones((909, 749))
        elif self.city == &#34;NewTown&#34;:
            self.density_matrix = np.ones((38, 38))
    elif self.city == &#34;Delft&#34;:
        try:
            if self.purge_cache:
                raise FileNotFoundError
            self.density_matrix = np.load(&#34;env/database/delft/density_matrix.npy&#34;)
            #print(&#34;loading from db&#34;)

        except FileNotFoundError:
            picca2 = Image.open(self.url_pop)
            picca2 = picca2.convert(&#39;RGB&#39;)
            self.width, self.height = picca2.size  # obtaining dimensions of figure

            self.density_matrix = np.zeros((self.width, self.height))  # setting up the numpy array
            for i in range(0, self.width):
                for j in range(0, self.height):

                    coordinates = i, j  # creating tuple as input of the next line
                    red, green, blue = picca2.getpixel(coordinates)  # obtaining the values of RGB for every pixel

                    # Pop density = pop/m^2, source = https://delft.incijfers.nl/jive?cat_show=Bevolking
                    if red &gt; 230 and green &gt; 230 and blue &gt; 230:  # assigning a value of 0 to all areas with no population density
                        self.density_matrix[i, j] = 0.01 / 100

                    elif red == 255 and green &gt; 195 and blue &gt; 150:  # assigning a value of 1 to all areas based on their population density
                        self.density_matrix[i, j] = 0.1 / 100

                    elif red == 244 and green == 156 and blue &gt; 5:  # assigning a value of 2 to all areas based on their population density
                        self.density_matrix[i, j] = 0.7 / 100

                    elif red == 231 and green == 77 and blue &gt; 20:  # assigning a value of 3 to all areas based on their population density
                        self.density_matrix[i, j] = 0.012

                    elif red == 192 and green == 31 and blue &gt; 35:  # assigning a value of 4 to all areas based on their population density
                        self.density_matrix[i, j] = 0.016

                    elif red == 130 and green &gt;= 0 and blue == 30:  # assigning a value of 5 to all areas based on their population density
                        self.density_matrix[i, j] = 0.023 #actual value: 23k citizens / km^2 (or 0.023 citizens per m^2)

                    else:  # assigning a cost of 0 to pixels that meet none of these if statements
                        self.density_matrix[i, j] = 0.01 / 100
                        self.density_matrix[i, j] = self.density_matrix[i][j - 1]

            #np.save(&#34;env/database/delft/density_matrix.npy&#34;, self.density_matrix)

        # self.density_matrix = self.density_matrix.transpose()
    elif self.city == &#34;NewYork&#34;:
        try:
            if self.purge_cache:
                raise FileNotFoundError
            self.density_matrix = np.load(&#34;env/database/ny/density_matrix.npy&#34;)
            #print(&#34;loading from db&#34;)

        except FileNotFoundError:
            picca2 = Image.open(self.url_pop)
            picca2 = picca2.convert(&#39;RGB&#39;)
            self.width, self.height = picca2.size  # obtaining dimensions of figure

            self.density_matrix = np.zeros((self.width, self.height))  # setting up the numpy array
            for i in range(0, self.width):
                for j in range(0, self.height):

                    coordinates = i, j  # creating tuple as input of the next line
                    red, green, blue = picca2.getpixel(coordinates)  # obtaining the values of RGB for every pixel

                    # Pop density = pop/m^2, source = https://delft.incijfers.nl/jive?cat_show=Bevolking
                    if red == 230 and green == 223 and blue == 20:  # Yellow, 30,000 - 150,000 ppl / square km
                        self.density_matrix[i, j] = 0.09

                    elif red == 93 and green == 69 and blue == 71:  # dark dark red (lowest ppl dens, 1,500 - 3,330 ppl / sq km)
                        self.density_matrix[i, j] = (1500 + 3300) / (2*1e6)

                    elif red == 167 and green == 28 and blue == 38:  # (dark)-red (3,330 - 7,000)
                        self.density_matrix[i, j] = (3330 + 7000) / (2*1e6)

                    elif red == 227 and green == 143 and blue == 64:  # orange, (7,000 - 30,000) ppl / sq KM
                        self.density_matrix[i, j] = (7000 + 30000)  / (2*1e6)

                    elif red == 35 and green == 34 and blue == 39:  # assigning a value of 4 to all areas based on their population density
                        self.density_matrix[i, j] = 0.0

                    elif red == 96 and green == 96 and blue == 99:  # assigning a value of 5 to all areas based on their population density
                        self.density_matrix[i, j] = 0.0 #actual value: 23k citizens / km^2 (or 0.023 citizens per m^2)

                    else:  # If a color is not matched, throw a warning, and take the average of the four surrounding points (
                        print(&#34;WARNING: Unmatched color in NY, color = ({}, {}, {})&#34;.format(red, green, blue))
                        self.density_matrix[i, j] = 0.25 * (self.density_matrix[i][j + 1] + self.density_matrix[i][j - 1] + self.density_matrix[i-1][j] + self.density_matrix[i+1][j])

            #np.save(&#34;env/database/newyork/density_matrix.npy&#34;, self.density_matrix)

    elif self.city == &#34;Paris&#34;:
        try:
            if self.purge_cache:
                raise FileNotFoundError
            self.density_matrix = np.load(&#34;env/database/paris/density_matrix.npy&#34;)
            #print(&#34;loading from db&#34;)

        except FileNotFoundError:
            picca2 = Image.open(self.url_pop)
            picca2 = picca2.convert(&#39;RGB&#39;)
            self.width, self.height = picca2.size  # obtaining dimensions of figure

            self.density_matrix = np.zeros((self.width, self.height))  # setting up the numpy array
            for i in range(0, self.width):
                for j in range(0, self.height):

                    coordinates = i, j  # creating tuple as input of the next line
                    red, green, blue = picca2.getpixel(coordinates)  # obtaining the values of RGB for every pixel

                    # Pop density = pop/m^2, source = https://delft.incijfers.nl/jive?cat_show=Bevolking
                    if red == 142 and green == 29 and blue == 24: #Dark-red = &gt; 50,000 per km^2 #8E1D18 (142, 29, 24)

                        self.density_matrix[i, j] = 50000 / 1e6

                    elif red == 197 and green == 50 and blue == 45:  # Red = 25,000 - 50,000 per km^2 #C5322D (197, 50, 45)
                        self.density_matrix[i, j] = (3*25000 + 50000) / (4*1e6)

                    elif red == 221 and green == 100 and blue == 73:  # Orange = 10,000-25,000 per km^2 #DD6449 (221, 100, 73)
                        self.density_matrix[i, j] = (3*10000 + 25000) / (4*1e6)

                    elif red == 223 and green == 140 and blue == 112:  # Semi-orange = 5,000 - 10,000 per km^2 #DF8C70 (223, 140, 112)
                        self.density_matrix[i, j] = (3*5000 + 10000)  / (4*1e6)

                    elif red == 206 and green == 212 and blue == 213:  # White = &lt;2,500 per km^2 #CED4D5 (206, 212, 213)
                        self.density_matrix[i, j] = (0 + 2500) / (2*1e6)

                    elif red == 95 and green == 144 and blue == 180:  # White = &lt;2,500 per km^2 #CED4D5 (206, 212, 213)
                        self.density_matrix[i, j] = 0.0

                    # elif red == 96 and green == 96 and blue == 99:  # assigning a value of 5 to all areas based on their population density
                    #     self.density_matrix[i, j] = 0.0 #actual value: 23k citizens / km^2 (or 0.023 citizens per m^2)

                    else:  # If a color is not matched, throw a warning, and take the average of the four surrounding points (
                        print(&#34;WARNING: Unmatched color in Paris, color = ({}, {}, {})&#34;.format(red, green, blue))
                        self.density_matrix[i, j] = 0.25 * (self.density_matrix[i][j + 1] + self.density_matrix[i][j - 1] + self.density_matrix[i-1][j] + self.density_matrix[i+1][j])

            #np.save(&#34;env/database/paris/density_matrix.npy&#34;, self.density_matrix)

    else:
        raise Exception(&#34;Unknown city&#34;)</code></pre>
</details>
</dd>
<dt id="github_version.env.loadEnvironment.loadEnvironment.loadShelteringData"><code class="name flex">
<span>def <span class="ident">loadShelteringData</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that is ran whenever the loadEnvironment class is initialized. It loads the sheltering data of the current city.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadShelteringData(self):
    &#39;&#39;&#39;
    Method that is ran whenever the loadEnvironment class is initialized. It loads the sheltering data of the current city.
    &#39;&#39;&#39;
    if self.city == &#34;CityGrid&#34;:
        self.generateCityGrid(block_width = 4, block_height=4, street_width=2, n_blocks_width=5, n_blocks_height=5, position_river=&#34;middle&#34;, width_river=2, n_block_river=2 )
        return

    if self.url_shelter == None:
        self.shelter_matrix = np.ones((909, 749))
        self.shelter_category = np.zeros((909, 749), dtype=int)
        self.shelter_category_names = np.array([&#34;Home Area&#34;])
    else:
        picca = Image.open(self.url_shelter)
        picca = picca.convert(&#39;RGB&#39;)
        width, height = picca.size  # obtaining dimensions of figure
        self.width = width
        self.height = height

        shelter_factor = np.zeros((width, height))  # setting up the numpy array
        self.isWater = np.zeros((width,height))
        self.shelter_category = np.zeros((width, height), dtype=int)
        unique_colors = []
        if self.city == &#34;NewTown&#34;:
            self.shelter_category_names = np.array(
                [&#34;Error&#34;, &#34;Office&#34;, &#34;Water&#34;, &#34;Street&#34;, &#34;Event Location&#34;, &#34;Home Area&#34;, &#34;Small Street&#34;, &#34;Meadow&#34;])

            for i in range(0,width):
                for j in range(0,height):
                    coordinates = i, j  # creating tuple as input of the next line
                    red, green, blue = picca.getpixel(coordinates)  # obtaining the values of RGB for every pixel

                    if red == 0 and green == 128 and blue == 0:
                        # A green pixel is a park / meadow so has 0 sheltering
                        self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Meadow&#34;)[0][0])
                        shelter_factor[i,j] = 0.001 # to avoid divide by zero errors
                    elif red == 0 and green == 0 and blue == 255:
                        # Blue = urban area, so 2.5 sheltering
                        self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Home Area&#34;)[0][0])
                        shelter_factor[i,j] = 5
                    elif red == 0 and green == 0 and blue == 0:
                        self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Street&#34;)[0][0])
                        # Road, so 1.5 sheltering
                        shelter_factor[i,j] = 2
                    elif red == 255 and green == 0 and blue == 0:
                        self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Office&#34;)[0][0])
                        shelter_factor[i,j] = 7.5
                    else:
                        print(&#34;Color not matched is {}&#34;.format((red, green, blue)))
                        raise Exception(&#34;One color is not matched&#34;)

        # For new delft
        # pink = (204, 57, 209) = office
        # blue = (19,0,245)     = water
        # yellow = (255,255,0) = street
        # red = (234, 51, 35)   = event location
        # black = (0,0,0)       = home area
        # white = (255,255,255) = small street
        # green = (55, 126, 34) = meadow


        elif self.city == &#34;Delft&#34;:
            self.shelter_category_names = np.array(
                [&#34;Error&#34;, &#34;Office&#34;, &#34;Water&#34;, &#34;Street&#34;, &#34;Event Location&#34;, &#34;Home Area&#34;, &#34;Small Street&#34;, &#34;Meadow&#34;])
            shelter_cat_url = &#34;env/database/delft/shelter_category_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
            isWater_url = &#34;env/database/delft/is_water_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
            shelterMatrixUrl = &#34;env/database/delft/shelter_matrix_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
            try:
                if self.purge_cache:
                    raise FileNotFoundError
                #print(&#34;loading from db&#34;)

                self.shelter_category = np.load(shelter_cat_url)
                self.isWater = np.load(isWater_url) # This is redundant!
                self.shelter_matrix = np.load(shelterMatrixUrl)
            except FileNotFoundError:
                for i in range(0, width):
                    for j in range(0, height):

                        coordinates = i, j  # creating tuple as input of the next line
                        red, green, blue = picca.getpixel(coordinates)  # obtaining the values of RGB for every pixel
                        color = (red,green,blue)

                        if red == 204 and green == 57 and blue == 209:  # Pink, office
                            shelter_factor[i, j] = 7.5
                            self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Office&#34;)[0][0])
                        elif red == 55 and green == 126 and blue == 34:
                            shelter_factor[i,j] = 0
                            self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Meadow&#34;)[0][0])
                        elif red == 19 and green == 0 and blue == 245:  # blue, water
                            shelter_factor[i, j] = 0
                            self.isWater[i,j] = 1
                            # print(&#34;categorising water at position {}&#34;.format((i,j)))
                            self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Water&#34;)[0][0])
                        elif red == 255 and green == 255 and blue == 0:  # yellow, street
                            shelter_factor[i, j] = 3.5
                            self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Street&#34;)[0][0])
                        elif red == 234 and green == 51 and blue == 35: # red, event location
                            shelter_factor[i,j] = 0
                            self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Event Location&#34;)[0][0])
                        elif red == 0 and green == 0 and blue == 0: # black, home location
                            shelter_factor[i,j] = 5
                            self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Home Area&#34;)[0][0])
                        elif red == 255 and green == 255 and blue == 255:
                            shelter_factor[i,j] = 2.5 # white, small roads
                            self.shelter_category[i, j] = int(np.where(self.shelter_category_names == &#34;Small Street&#34;)[0][0])
                        else:
                            print(picca.getpixel(coordinates))
                            raise Exception(&#34;Pixel found in city Delft that can&#39;t be defined.&#34;)

                if np.count_nonzero(self.shelter_category == 0) &gt; 0:
                        raise Exception(&#34;Not all gridpoints have been categorised&#34;)

                # self.shelter_matrix = shelter_factor.transpose()  # for some reason, the array is sideways, here it gets transposed to the correct orientation
                self.shelter_matrix = shelter_factor
                self.shelter_matrix[self.shelter_matrix == 0] = 0.001

                #np.save(shelter_cat_url, self.shelter_category)
                #np.save(shelterMatrixUrl, self.shelter_matrix)
                #np.save(isWater_url, self.isWater)

        elif self.city == &#34;NewYork&#34;:
            changedensmap = Image.open(self.url_modifyPopDens)
            changedensmap = changedensmap.convert(&#34;RGB&#34;)


            # 170, 218, 255 = blue = water
            # 199, 233, 199 = green = parks
            # 255, 234, 160 = large roads = yellow
            # 255, 255, 255 = white = roads
            # 232, 232, 232 = grey = residential
            # 254, 247, 224 = light yellow (office districts)
            # 252, 232, 230 = pink, hospital

            self.shelter_category_names = np.array(
                [&#34;Error&#34;, &#34;Office&#34;, &#34;Water&#34;, &#34;Street&#34;, &#34;Event Location&#34;, &#34;Home Area&#34;, &#34;Small Street&#34;, &#34;Meadow&#34;])
            shelter_cat_url = &#34;env/database/newyork/shelter_category_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
            isWater_url = &#34;env/database/newyork/is_water_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
            shelterMatrixUrl = &#34;env/database/newyork/shelter_matrix_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
            try:
                if self.purge_cache:
                    raise FileNotFoundError
                #print(&#34;loading from db&#34;)
                self.shelter_category = np.load(shelter_cat_url)
                self.isWater = np.load(isWater_url)  # This is redundant!
                self.shelter_matrix = np.load(shelterMatrixUrl)
            except FileNotFoundError:
                for i in range(0, width):
                    for j in range(0, height):
                        coordinates = i, j  # creating tuple as input of the next line
                        red, green, blue = picca.getpixel(
                            coordinates)  # obtaining the values of RGB for every pixel

                        red_cd, green_cd, blue_cd = changedensmap.getpixel(coordinates)

                        if red == 170 and green == 218 and blue == 255:  # blue, water
                            shelter_factor[i, j] = 0
                            self.isWater[i, j] = 1
                            self.shelter_category[i, j] = int(
                                np.where(self.shelter_category_names == &#34;Water&#34;)[0][0])
                        elif red == 199 and green == 233 and blue == 199: # green, parks
                            shelter_factor[i, j] = 1
                            self.density_matrix[i, j] = 0
                            self.shelter_category[i, j] = int(
                                np.where(self.shelter_category_names == &#34;Meadow&#34;)[0][0])
                        elif red == 255 and green == 234 and blue == 160:  # yellow
                            shelter_factor[i, j] = 2.5
                            self.shelter_category[i, j] = int(
                                np.where(self.shelter_category_names == &#34;Street&#34;)[0][0])
                        elif red == 255 and green == 255 and blue == 255:  # white, small street
                            shelter_factor[i, j] = 2.5
                            self.shelter_category[i, j] = int(
                                np.where(self.shelter_category_names == &#34;Small Street&#34;)[0][0])

                        elif (red == 253 and green == 246 and blue == 224) or (red == 232 and green == 232 and blue == 232) or (red == 252 and green == 232 and blue == 230):  # home / office area
                            if red_cd == 0 and green_cd == 0 and blue_cd == 0:
                                shelter_factor[i, j] = 7.5 #offices
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Office&#34;)[0][0])
                            else:
                                shelter_factor[i, j] = 5
                                self.shelter_category[i, j] = int(
                                    np.where(self.shelter_category_names == &#34;Home Area&#34;)[0][0])

                        else:
                            print(&#34;Color not accounted for rgb({}, {}, {})&#34;.format(red, green, blue))

                self.shelter_matrix = shelter_factor
                self.shelter_matrix[self.shelter_matrix == 0] = 0.001 # to avoid division by 0 errors
                #np.save(shelter_cat_url, self.shelter_category)
                #np.save(shelterMatrixUrl, self.shelter_matrix)
                #np.save(isWater_url, self.isWater)

        elif self.city == &#34;Paris&#34;:
            # changedensmap = Image.open(self.url_modifyPopDens)
            # changedensmap = changedensmap.convert(&#34;RGB&#34;)

            # 170, 218, 255 = blue = water
            # 199, 233, 199 = green = parks
            # 255, 234, 160 = large roads = yellow
            # 255, 255, 255 = white = roads
            # 232, 232, 232 = grey = residential
            # 254, 247, 224 = light yellow (office districts)
            # 252, 232, 230 = pink, hospital

            self.shelter_category_names = np.array(
                [&#34;Error&#34;, &#34;Office&#34;, &#34;Water&#34;, &#34;Street&#34;, &#34;Event Location&#34;, &#34;Home Area&#34;, &#34;Small Street&#34;, &#34;Meadow&#34;])
            shelter_cat_url = &#34;env/database/paris/shelter_category_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
            isWater_url = &#34;env/database/paris/is_water_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
            shelterMatrixUrl = &#34;env/database/paris/shelter_matrix_waterSetting=&#34; + str(self.waterSetting) + &#34;.npy&#34;
            try:
                if self.purge_cache:
                    raise FileNotFoundError
                #print(&#34;loading from db&#34;)
                self.shelter_category = np.load(shelter_cat_url)
                self.isWater = np.load(isWater_url)  # This is redundant!
                self.shelter_matrix = np.load(shelterMatrixUrl)
            except FileNotFoundError:
                for i in range(0, width):
                    for j in range(0, height):
                        coordinates = i, j  # creating tuple as input of the next line
                        red, green, blue = picca.getpixel(
                            coordinates)  # obtaining the values of RGB for every pixel

                        # red_cd, green_cd, blue_cd = changedensmap.getpixel(coordinates)

                        if red == 170 and green == 218 and blue == 255:  # blue, water
                            shelter_factor[i, j] = 0
                            self.isWater[i, j] = 1
                            self.shelter_category[i, j] = int(
                                np.where(self.shelter_category_names == &#34;Water&#34;)[0][0])
                        elif red == 199 and green == 233 and blue == 199: # green, parks
                            shelter_factor[i, j] = 0
                            self.shelter_category[i, j] = int(
                                np.where(self.shelter_category_names == &#34;Meadow&#34;)[0][0])
                        elif red == 255 and green == 234 and blue == 160:  # yellow
                            shelter_factor[i, j] = 3.5
                            self.shelter_category[i, j] = int(
                                np.where(self.shelter_category_names == &#34;Street&#34;)[0][0])
                        elif red == 255 and green == 255 and blue == 255:  # white, small street
                            shelter_factor[i, j] = 2.5
                            self.shelter_category[i, j] = int(
                                np.where(self.shelter_category_names == &#34;Small Street&#34;)[0][0])

                        elif (red == 253 and green == 246 and blue == 224) or (red == 252 and green == 232 and blue == 230):
                            # pink = hospital = considered office
                            # light yellow = offices
                            shelter_factor[i, j] = 7.5  # offices
                            self.shelter_category[i, j] = int(
                                np.where(self.shelter_category_names == &#34;Office&#34;)[0][0])

                        elif (red == 232 and green == 232 and blue == 232):  # home / office area
                            shelter_factor[i, j] = 5
                            self.shelter_category[i, j] = int(
                                np.where(self.shelter_category_names == &#34;Home Area&#34;)[0][0])

                        else:
                            print(&#34;Color not accounted for rgb({}, {}, {})&#34;.format(red, green, blue))

                self.shelter_matrix = shelter_factor
                self.shelter_matrix[self.shelter_matrix == 0] = 0.001 # to avoid division by 0 errors
                #np.save(shelter_cat_url, self.shelter_category)
                #np.save(shelterMatrixUrl, self.shelter_matrix)
                #np.save(isWater_url, self.isWater)

        else:
            raise Exception(&#34;Sheltering data is not defined for this city&#34;)</code></pre>
</details>
</dd>
<dt id="github_version.env.loadEnvironment.loadEnvironment.modifyPopDensityWater"><code class="name flex">
<span>def <span class="ident">modifyPopDensityWater</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that is ran whenever the loadEnvironment class is initialized. It modifies the population density on water.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def modifyPopDensityWater(self):
    &#39;&#39;&#39;
    Method that is ran whenever the loadEnvironment class is initialized. It modifies the population density on water.
    &#39;&#39;&#39;
    if self.city == &#34;Delft&#34; or self.city == &#34;NewYork&#34; or self.city == &#34;Paris&#34;:
        # print(&#34;Modifying water&#34;)
        self.density_matrix[self.isWater == 1] = 0.01
        # self.shelter_matrix[self.isWater == 1] = 2.5
        if len(np.where(self.isWater)[0]) == 0:
            raise Exception(&#34;Trying to remove water, but there is no water&#34;)
    else:
        print(&#34;Warning, function modifyPopDensityWater called but is not working&#34;)</code></pre>
</details>
</dd>
<dt id="github_version.env.loadEnvironment.loadEnvironment.modifyPopulationDensity"><code class="name flex">
<span>def <span class="ident">modifyPopulationDensity</span></span>(<span>self, target_array)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a target_array as input, which should be of the same length as shelter_category_names.
It moves x % of the population to that area, so the total array should sum to 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def modifyPopulationDensity(self, target_array):
    &#39;&#39;&#39;
     Takes a target_array as input, which should be of the same length as shelter_category_names.
     It moves x % of the population to that area, so the total array should sum to 1.
    &#39;&#39;&#39;



    if len(target_array) != len(self.shelter_category_names):
        raise Exception(&#34;Modification array should be of same size as category names array&#34;)

    total_population = sum(sum(self.density_matrix))

    self.density_matrix_modified = np.zeros_like(self.density_matrix)


    # The weights-list should be pairwise multiplied with the area-size to find the constant

    pop_dens_constant = total_population / sum(np.multiply(self.area_per_shelter_category, target_array))

    for i in range(0, self.width):
        for j in range(0, self.height):
            self.density_matrix_modified[i,j] = target_array[self.shelter_category[i,j]] * pop_dens_constant

    # print(sum(sum(self.density_matrix_modified)) / total_population)

    new_total_population = sum(sum(self.density_matrix_modified))

    # print(&#34;Initial total pop = {}, final total pop = {}&#34;.format(total_population, new_total_population))

    diff_pop = abs((new_total_population / total_population) - 1)
    if diff_pop &gt; 0.05:
        raise Exception(&#34;Total population count changed more than 5% while moving people around - this can&#39;t be right!&#34;)

    if diff_pop &gt; 0.001:
        print(&#34;WARNING: Total population count changed by {}%&#34;.format(diff_pop*100))

    self.density_matrix = self.density_matrix_modified.copy()</code></pre>
</details>
</dd>
<dt id="github_version.env.loadEnvironment.loadEnvironment.removePopDensityFromWater"><code class="name flex">
<span>def <span class="ident">removePopDensityFromWater</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method removes population density from water.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removePopDensityFromWater(self):
    &#39;&#39;&#39;
    This method removes population density from water.
    &#39;&#39;&#39;
    # print(&#34;removing pop density from water&#34;)
    if self.city == &#34;Delft&#34; or self.city == &#34;NewYork&#34; or self.city == &#34;Paris&#34;:
        self.density_matrix[self.isWater == 1] = 0.0
        # self.shelter_matrix[self.isWater == 1] = 2.5
        if len(np.where(self.isWater)[0]) == 0:
            raise Exception(&#34;Trying to remove water, but there is no water&#34;)
        # print(&#34;Not removing water because city is {}&#34;.format(self.city))
        # raise Exception(&#34;Removing water is only available for Delft&#34;)
    else:
        print(&#34;Warning, function removePopDensityFromWater called but is not working&#34;)</code></pre>
</details>
</dd>
<dt id="github_version.env.loadEnvironment.loadEnvironment.scaleMap"><code class="name flex">
<span>def <span class="ident">scaleMap</span></span>(<span>self, na, scaling_factor, scaling_method='average', file_name='')</span>
</code></dt>
<dd>
<div class="desc"><p>@param na: numpy array of the map that is to be scaled
@param scaling_factor: factor by which this map should be scaled
@param scaling_method: method to use (mode / average)
@param file_name: file name in which the map can be stored.
@return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaleMap(self, na, scaling_factor, scaling_method=&#34;average&#34;, file_name=&#34;&#34;):
    &#39;&#39;&#39;

    @param na: numpy array of the map that is to be scaled
    @param scaling_factor: factor by which this map should be scaled
    @param scaling_method: method to use (mode / average)
    @param file_name: file name in which the map can be stored.
    @return:
    &#39;&#39;&#39;
    file_loc = &#34;env/database/scaled_maps/&#34; + &#34;c=&#34; + self.city + &#34;_n=&#34; + file_name + &#34;_s=&#34; + str(scaling_factor) + &#34;_m=&#34; + scaling_method + &#34;_ws=&#34; + str(self.waterSetting) + &#34;.npy&#34;
    try:
        if self.purge_cache:
            raise FileNotFoundError
        #print(&#34;loading from db&#34;)

        scaled_map = np.load(file_loc)
        #print(&#34;loading from db&#34;)
    except FileNotFoundError:
        if scaling_factor == 1:
            return na

        block_shape = (scaling_factor, scaling_factor)

        width_scaled = math.floor(na.shape[0] / block_shape[0])
        height_scaled = math.floor(na.shape[1] / block_shape[1])

        width_cropped = width_scaled * block_shape[0]
        height_cropped = height_scaled * block_shape[1]

        view = view_as_blocks(na[:width_cropped, :height_cropped], block_shape)
        flatView = view.reshape(view.shape[0], view.shape[1], -1)

        if scaling_method == &#34;average&#34;:
            scaled_map = np.average(flatView, axis=2)
        elif scaling_method == &#34;mode&#34;:
            scaled_map = stats.mode(flatView, axis=2)[0].reshape((width_scaled, height_scaled))
        elif scaling_method == &#34;original_AABMS&#34;:
            scaled_map = na[0:na.shape[0]:scaling_factor, 0:na.shape[1]:scaling_factor]
        else:
            raise Exception(&#34;Unknown scaling mode.&#34;)

        #np.save(file_loc, scaled_map)

    return scaled_map</code></pre>
</details>
</dd>
<dt id="github_version.env.loadEnvironment.loadEnvironment.statisticsPopulationDensity"><code class="name flex">
<span>def <span class="ident">statisticsPopulationDensity</span></span>(<span>self, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs statistics of the distribution of people in a city.
verbose: boolean, whether or not to print the statistics</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def statisticsPopulationDensity(self, verbose=True):
    &#39;&#39;&#39;
    Outputs statistics of the distribution of people in a city.
    verbose: boolean, whether or not to print the statistics
    &#39;&#39;&#39;
    # if self.url_modifyPopDens == None:
    #     raise Exception(&#34;Cannot modify population density - no image given&#34;)
    # else:
    #     figure = Image.open(self.url_modifyPopDens)
    #     figure = figure.convert(&#39;RGB&#39;)

    width, height = self.density_matrix.shape  # obtaining dimensions of figure


    # CODE: 0 = home area, 1 = office area, 2 = transport area, 3 = other
    self.area_code = np.zeros((width, height))

    self.population_per_category = np.zeros((len(self.shelter_category_names)))

    self.area = self.grid_size_m_x * self.grid_size_m_y


    width_m = self.width_meters / self.density_matrix.shape[0]
    height_m = self.height_meters / self.density_matrix.shape[1]
    area_m = width_m * height_m

    total_pop = 0
    for i in range(0, width):
        for j in range(0, height):
            total_pop += area_m * self.density_matrix[i, j]

    if verbose:
        print(&#34;Total population of {} million people&#34;.format(total_pop/1e6))

    for i in range(len(self.area_per_shelter_category)):
        self.area_per_shelter_category[i] = np.count_nonzero(self.shelter_category == i)

    for i in range(0, width):
        for j in range(0, height):
            try:
                self.population_per_category[self.shelter_category[i, j]] += self.density_matrix[i, j]
            except IndexError:
                print(&#34;debug here&#34;)
    if abs(1 - sum(self.population_per_category) / sum(sum(self.density_matrix))) &gt; 0.0001:
        raise Exception(&#34;Not all population accounted for in the statistics.&#34;)

    if verbose:
        total_pop = sum(self.population_per_category)
        for idx, category in enumerate(self.shelter_category_names):
            relative_dens = self.population_per_category[idx] / self.area_per_shelter_category[idx]
            print(&#34;Population in category {} is {} (is {}% of total, relative density = {})&#34;.format(category, self.population_per_category[idx], 100*self.population_per_category[idx]/total_pop, relative_dens))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="github_version.env" href="index.html">github_version.env</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="github_version.env.loadEnvironment.loadEnvironment" href="#github_version.env.loadEnvironment.loadEnvironment">loadEnvironment</a></code></h4>
<ul class="">
<li><code><a title="github_version.env.loadEnvironment.loadEnvironment.generateCityGrid" href="#github_version.env.loadEnvironment.loadEnvironment.generateCityGrid">generateCityGrid</a></code></li>
<li><code><a title="github_version.env.loadEnvironment.loadEnvironment.loadPopulationDensity" href="#github_version.env.loadEnvironment.loadEnvironment.loadPopulationDensity">loadPopulationDensity</a></code></li>
<li><code><a title="github_version.env.loadEnvironment.loadEnvironment.loadShelteringData" href="#github_version.env.loadEnvironment.loadEnvironment.loadShelteringData">loadShelteringData</a></code></li>
<li><code><a title="github_version.env.loadEnvironment.loadEnvironment.modifyPopDensityWater" href="#github_version.env.loadEnvironment.loadEnvironment.modifyPopDensityWater">modifyPopDensityWater</a></code></li>
<li><code><a title="github_version.env.loadEnvironment.loadEnvironment.modifyPopulationDensity" href="#github_version.env.loadEnvironment.loadEnvironment.modifyPopulationDensity">modifyPopulationDensity</a></code></li>
<li><code><a title="github_version.env.loadEnvironment.loadEnvironment.removePopDensityFromWater" href="#github_version.env.loadEnvironment.loadEnvironment.removePopDensityFromWater">removePopDensityFromWater</a></code></li>
<li><code><a title="github_version.env.loadEnvironment.loadEnvironment.scaleMap" href="#github_version.env.loadEnvironment.loadEnvironment.scaleMap">scaleMap</a></code></li>
<li><code><a title="github_version.env.loadEnvironment.loadEnvironment.statisticsPopulationDensity" href="#github_version.env.loadEnvironment.loadEnvironment.statisticsPopulationDensity">statisticsPopulationDensity</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>